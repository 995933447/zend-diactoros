{
    "docs": [
        {
            "location": "/",
            "text": "zend-diactoros\n\n\nMaster:\n\n\n\n\nDevelop:\n\n\n\n\n\n\n\nDiactoros (pronunciation: \n/d\u026a\u028ckt\u0252r\u0252s/\n): an epithet for Hermes, meaning literally, \"the messenger.\"\n\n\n\n\nThis package supercedes and replaces \nphly/http\n.\n\n\nzend-diactoros\n is a PHP package containing implementations of the \naccepted PSR-7 HTTP message interfaces\n, as well as a \"server\" implementation similar to \nnode's http.Server\n.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-diactoros/issues\n\n\nIssue patches to https://github.com/zendframework/zend-diactoros/pulls\n\n\n\n\nDocumentation\n\n\nDocumentation is available at:\n\n\n\n\nhttps://zendframework.github.io/zend-diactoros/\n\n\n\n\nSource files for documentation are \nin the doc/ tree\n.",
            "title": "Home"
        },
        {
            "location": "/#zend-diactoros",
            "text": "Master:  \nDevelop:    Diactoros (pronunciation:  /d\u026a\u028ckt\u0252r\u0252s/ ): an epithet for Hermes, meaning literally, \"the messenger.\"   This package supercedes and replaces  phly/http .  zend-diactoros  is a PHP package containing implementations of the  accepted PSR-7 HTTP message interfaces , as well as a \"server\" implementation similar to  node's http.Server .   File issues at https://github.com/zendframework/zend-diactoros/issues  Issue patches to https://github.com/zendframework/zend-diactoros/pulls",
            "title": "zend-diactoros"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is available at:   https://zendframework.github.io/zend-diactoros/   Source files for documentation are  in the doc/ tree .",
            "title": "Documentation"
        },
        {
            "location": "/overview/",
            "text": "zend-diactoros: HTTP Messages\n\n\nzend-diactoros\n is a PHP package containing implementations of the \naccepted PSR-7 HTTP message\ninterfaces\n, as\nwell as a \"server\" implementation similar to \nnode's http.Server\n.\n\n\nThis package exists:\n\n\n\n\nto provide a proof-of-concept of the accepted PSR HTTP message interfaces with relation to\n  server-side applications.\n\n\nto provide a node-like paradigm for PHP front controllers.\n\n\nto provide a common methodology for marshaling a request from the server environment.",
            "title": "Overview"
        },
        {
            "location": "/overview/#zend-diactoros-http-messages",
            "text": "zend-diactoros  is a PHP package containing implementations of the  accepted PSR-7 HTTP message\ninterfaces , as\nwell as a \"server\" implementation similar to  node's http.Server .  This package exists:   to provide a proof-of-concept of the accepted PSR HTTP message interfaces with relation to\n  server-side applications.  to provide a node-like paradigm for PHP front controllers.  to provide a common methodology for marshaling a request from the server environment.",
            "title": "zend-diactoros: HTTP Messages"
        },
        {
            "location": "/install/",
            "text": "Installation and Requirements\n\n\nInstall this library using composer:\n\n\n$ composer require zendframework/zend-diactoros\n\n\n\nzend-diactoros\n has the following dependencies (which are managed by Composer):\n\n\n\n\npsr/http-message\n, which defines interfaces for HTTP messages, including requests and responses.\n  \nzend-diactoros\n provides implementations of each of these.",
            "title": "Installation"
        },
        {
            "location": "/install/#installation-and-requirements",
            "text": "Install this library using composer:  $ composer require zendframework/zend-diactoros  zend-diactoros  has the following dependencies (which are managed by Composer):   psr/http-message , which defines interfaces for HTTP messages, including requests and responses.\n   zend-diactoros  provides implementations of each of these.",
            "title": "Installation and Requirements"
        },
        {
            "location": "/usage/",
            "text": "Usage\n\n\nUsage will differ based on whether you are writing an HTTP client, or a server-side application.\n\n\nFor HTTP client purposes, you will create and populate a \nRequest\n instance, and the client should\nreturn a \nResponse\n instance.\n\n\nFor server-side applications, you will create a \nServerRequest\n instance, and populate and return a\n\nResponse\n instance.\n\n\nHTTP Clients\n\n\nA client will \nsend\n a request, and \nreturn\n a response. As a developer, you will \ncreate\n and\n\npopulate\n the request, and then \nintrospect\n the response.  Both requests and responses are\nimmutable; if you make changes \u2014 e.g., by calling setter methods \u2014 you must capture the return\nvalue, as it is a new instance.\n\n\n// Create a request\n$request = (new Zend\\Diactoros\\Request())\n    ->withUri(new Zend\\Diactoros\\Uri('http://example.com'))\n    ->withMethod('PATCH')\n    ->withAddedHeader('Authorization', 'Bearer ' . $token)\n    ->withAddedHeader('Content-Type', 'application/json');\n\n// OR:\n$request = new Zend\\Diactoros\\Request(\n    'http://example.com',\n    'PATCH',\n    'php://memory',\n    [\n        'Authorization' => 'Bearer ' . $token,\n        'Content-Type'  => 'application/json',\n    ]\n);\n\n// If you want to set a non-origin-form request target, set the\n// request-target explicitly:\n$request = $request->withRequestTarget((string) $uri);       // absolute-form\n$request = $request->withRequestTarget($uri->getAuthority()); // authority-form\n$request = $request->withRequestTarget('*');                 // asterisk-form\n\n// Once you have the instance:\n$request->getBody()->write(json_encode($data));\n$response = $client->send($request);\n\nprintf(\"Response status: %d (%s)\\n\", $response->getStatusCode(), $response->getReasonPhrase());\nprintf(\"Headers:\\n\");\nforeach ($response->getHeaders() as $header => $values) {\n    printf(\"    %s: %s\\n\", $header, implode(', ', $values));\n}\nprintf(\"Message:\\n%s\\n\", $response->getBody());\n\n\n\n(Note: \nzend-diactoros\n does NOT ship with a client implementation; the above is just an\nillustration of a possible implementation.)\n\n\nServer-Side Applications\n\n\nServer-side applications will need to marshal the incoming request based on superglobals, and will\nthen populate and send a response.\n\n\nMarshaling an incoming request\n\n\nPHP contains a plethora of information about the incoming request, and keeps that information in a\nvariety of locations. \nZend\\Diactoros\\ServerRequestFactory::fromGlobals()\n can simplify marshaling\nthat information into a request instance.\n\n\nYou can call the factory method with or without the following arguments, in the following order:\n\n\n\n\n$server\n, typically \n$_SERVER\n\n\n$query\n, typically \n$_GET\n\n\n$body\n, typically \n$_POST\n\n\n$cookies\n, typically \n$_COOKIE\n\n\n$files\n, typically \n$_FILES\n\n\n\n\nThe method will then return a \nZend\\Diactoros\\ServerRequest\n instance. If any argument is omitted,\nthe associated superglobal will be used.\n\n\n$request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);\n\n\n\nWhen no cookie array is supplied, \nfromGlobals\n will first try to parse the supplied \ncookie\n header\nbefore falling back to the \n$_COOKIE\n superglobal. This is done because PHP has some legacy handling\nfor request parameters which were then registered as global variables. Due to this, cookies with a period\nin the name were renamed with underlines. By getting the cookies directly from the cookie header, you have\naccess to the original cookies in the way you set them in your application and they are send by the user\nagent.\n\n\nManipulating the response\n\n\nUse the response object to add headers and provide content for the response.  Writing to the body\ndoes not create a state change in the response, so it can be done without capturing the return\nvalue. Manipulating headers does, however.\n\n\n$response = new Zend\\Diactoros\\Response();\n\n// Write to the response body:\n$response->getBody()->write(\"some content\\n\");\n\n// Multiple calls to write() append:\n$response->getBody()->write(\"more content\\n\"); // now \"some content\\nmore content\\n\"\n\n// Add headers\n// Note: headers do not need to be added before data is written to the body!\n$response = $response\n    ->withHeader('Content-Type', 'text/plain')\n    ->withAddedHeader('X-Show-Something', 'something');\n\n\n\n\"Serving\" an application\n\n\nZend\\Diactoros\\Server\n mimics a portion of the API of node's \nhttp.Server\n class. It invokes a\ncallback, passing it an \nServerRequest\n, an \nResponse\n, and optionally a callback to use for\nincomplete/unhandled requests.\n\n\nYou can create a server in one of three ways:\n\n\n// Direct instantiation, with a callback handler, request, and response\n$server = new Zend\\Diactoros\\Server(\n    function ($request, $response, $done) {\n        $response->getBody()->write(\"Hello world!\");\n    },\n    $request,\n    $response\n);\n\n// Using the createServer factory, providing it with the various superglobals:\n$server = Zend\\Diactoros\\Server::createServer(\n    function ($request, $response, $done) {\n        $response->getBody()->write(\"Hello world!\");\n    },\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);\n\n// Using the createServerFromRequest factory, and providing it a request:\n$server = Zend\\Diactoros\\Server::createServerFromRequest(\n  function ($request, $response, $done) {\n      $response->getBody()->write(\"Hello world!\");\n  },\n  $request\n);\n\n\n\nServer callbacks can expect up to three arguments, in the following order:\n\n\n\n\n$request\n - the request object\n\n\n$response\n - the response object\n\n\n$done\n - an optional callback to call when complete\n\n\n\n\nOnce you have your server instance, you must instruct it to listen:\n\n\n$server->listen();\n\n\n\nAt this time, you can optionally provide a callback to \nlisten()\n; this will be passed to the\nhandler as the third argument (\n$done\n):\n\n\n$server->listen(function ($request, $response, $error = null) {\n    if (! $error) {\n        return;\n    }\n    // do something with the error...\n});\n\n\n\nTypically, the \nlisten\n callback will be an error handler, and can expect to receive the request,\nresponse, and error as its arguments (though the error may be null).",
            "title": "Usage"
        },
        {
            "location": "/usage/#usage",
            "text": "Usage will differ based on whether you are writing an HTTP client, or a server-side application.  For HTTP client purposes, you will create and populate a  Request  instance, and the client should\nreturn a  Response  instance.  For server-side applications, you will create a  ServerRequest  instance, and populate and return a Response  instance.",
            "title": "Usage"
        },
        {
            "location": "/usage/#http-clients",
            "text": "A client will  send  a request, and  return  a response. As a developer, you will  create  and populate  the request, and then  introspect  the response.  Both requests and responses are\nimmutable; if you make changes \u2014 e.g., by calling setter methods \u2014 you must capture the return\nvalue, as it is a new instance.  // Create a request\n$request = (new Zend\\Diactoros\\Request())\n    ->withUri(new Zend\\Diactoros\\Uri('http://example.com'))\n    ->withMethod('PATCH')\n    ->withAddedHeader('Authorization', 'Bearer ' . $token)\n    ->withAddedHeader('Content-Type', 'application/json');\n\n// OR:\n$request = new Zend\\Diactoros\\Request(\n    'http://example.com',\n    'PATCH',\n    'php://memory',\n    [\n        'Authorization' => 'Bearer ' . $token,\n        'Content-Type'  => 'application/json',\n    ]\n);\n\n// If you want to set a non-origin-form request target, set the\n// request-target explicitly:\n$request = $request->withRequestTarget((string) $uri);       // absolute-form\n$request = $request->withRequestTarget($uri->getAuthority()); // authority-form\n$request = $request->withRequestTarget('*');                 // asterisk-form\n\n// Once you have the instance:\n$request->getBody()->write(json_encode($data));\n$response = $client->send($request);\n\nprintf(\"Response status: %d (%s)\\n\", $response->getStatusCode(), $response->getReasonPhrase());\nprintf(\"Headers:\\n\");\nforeach ($response->getHeaders() as $header => $values) {\n    printf(\"    %s: %s\\n\", $header, implode(', ', $values));\n}\nprintf(\"Message:\\n%s\\n\", $response->getBody());  (Note:  zend-diactoros  does NOT ship with a client implementation; the above is just an\nillustration of a possible implementation.)",
            "title": "HTTP Clients"
        },
        {
            "location": "/usage/#server-side-applications",
            "text": "Server-side applications will need to marshal the incoming request based on superglobals, and will\nthen populate and send a response.",
            "title": "Server-Side Applications"
        },
        {
            "location": "/usage/#marshaling-an-incoming-request",
            "text": "PHP contains a plethora of information about the incoming request, and keeps that information in a\nvariety of locations.  Zend\\Diactoros\\ServerRequestFactory::fromGlobals()  can simplify marshaling\nthat information into a request instance.  You can call the factory method with or without the following arguments, in the following order:   $server , typically  $_SERVER  $query , typically  $_GET  $body , typically  $_POST  $cookies , typically  $_COOKIE  $files , typically  $_FILES   The method will then return a  Zend\\Diactoros\\ServerRequest  instance. If any argument is omitted,\nthe associated superglobal will be used.  $request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);  When no cookie array is supplied,  fromGlobals  will first try to parse the supplied  cookie  header\nbefore falling back to the  $_COOKIE  superglobal. This is done because PHP has some legacy handling\nfor request parameters which were then registered as global variables. Due to this, cookies with a period\nin the name were renamed with underlines. By getting the cookies directly from the cookie header, you have\naccess to the original cookies in the way you set them in your application and they are send by the user\nagent.",
            "title": "Marshaling an incoming request"
        },
        {
            "location": "/usage/#manipulating-the-response",
            "text": "Use the response object to add headers and provide content for the response.  Writing to the body\ndoes not create a state change in the response, so it can be done without capturing the return\nvalue. Manipulating headers does, however.  $response = new Zend\\Diactoros\\Response();\n\n// Write to the response body:\n$response->getBody()->write(\"some content\\n\");\n\n// Multiple calls to write() append:\n$response->getBody()->write(\"more content\\n\"); // now \"some content\\nmore content\\n\"\n\n// Add headers\n// Note: headers do not need to be added before data is written to the body!\n$response = $response\n    ->withHeader('Content-Type', 'text/plain')\n    ->withAddedHeader('X-Show-Something', 'something');",
            "title": "Manipulating the response"
        },
        {
            "location": "/usage/#serving-an-application",
            "text": "Zend\\Diactoros\\Server  mimics a portion of the API of node's  http.Server  class. It invokes a\ncallback, passing it an  ServerRequest , an  Response , and optionally a callback to use for\nincomplete/unhandled requests.  You can create a server in one of three ways:  // Direct instantiation, with a callback handler, request, and response\n$server = new Zend\\Diactoros\\Server(\n    function ($request, $response, $done) {\n        $response->getBody()->write(\"Hello world!\");\n    },\n    $request,\n    $response\n);\n\n// Using the createServer factory, providing it with the various superglobals:\n$server = Zend\\Diactoros\\Server::createServer(\n    function ($request, $response, $done) {\n        $response->getBody()->write(\"Hello world!\");\n    },\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);\n\n// Using the createServerFromRequest factory, and providing it a request:\n$server = Zend\\Diactoros\\Server::createServerFromRequest(\n  function ($request, $response, $done) {\n      $response->getBody()->write(\"Hello world!\");\n  },\n  $request\n);  Server callbacks can expect up to three arguments, in the following order:   $request  - the request object  $response  - the response object  $done  - an optional callback to call when complete   Once you have your server instance, you must instruct it to listen:  $server->listen();  At this time, you can optionally provide a callback to  listen() ; this will be passed to the\nhandler as the third argument ( $done ):  $server->listen(function ($request, $response, $error = null) {\n    if (! $error) {\n        return;\n    }\n    // do something with the error...\n});  Typically, the  listen  callback will be an error handler, and can expect to receive the request,\nresponse, and error as its arguments (though the error may be null).",
            "title": "\"Serving\" an application"
        },
        {
            "location": "/custom-responses/",
            "text": "Custom Responses\n\n\nWhen developing server-side applications, the message type you're most likely to create manually is\nthe response. In such cases, the standard signature can be an obstacle to usability. Let's review:\n\n\nclass Response implements ResponseInterface\n{\n    public function __construct($body = 'php://temp', $status = 200, array $headers = []);\n}\n\n\n\nSome standard use cases, however, make this un-wieldy:\n\n\n\n\nReturning a response containing HTML; in this case, you likely want to provide the HTML to the\n  constructor, not a stream with the HTML injected.\n\n\nReturning a response containing JSON; in this case, you likely want to provide the data to\n  serialize to JSON, not a stream containing serialized JSON.\n\n\nReturning a response with no content; in this case, you don't want to bother with the body at all.\n\n\nReturning a redirect response; in this case, you likely just want to specify the target for the\n  \nLocation\n header, and optionally the status code.\n\n\n\n\nStarting with version 1.1, Diactoros offers several custom response types for simplifying these\ncommon tasks.\n\n\nText Responses\n\n\nZend\\Diactoros\\Response\\TextResponse\n creates a plain text response. It sets the\n\nContent-Type\n header to \ntext/plain\n by default:\n\n\n$response = new TextResponse('Hello world!');\n\n\n\nThe constructor accepts two additional arguments: a status code and an array of headers.\n\n\n$response = new TextResponse($text, 200, ['Content-Type' => ['text/csv']]);\n\n\n\nHTML Responses\n\n\nZend\\Diactoros\\Response\\HtmlResponse\n allows specifying HTML as a payload, and sets the\n\nContent-Type\n header to \ntext/html\n by default:\n\n\n$response = new HtmlResponse($htmlContent);\n\n\n\nThe constructor allows passing two additional arguments: a status code, and an array of headers.\nThese allow you to further seed the initial state of the response, as well as to override the\n\nContent-Type\n header if desired:\n\n\n$response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' => ['application/xhtml+xml']]);\n\n\n\nHeaders must be in the same format as you would provide to the\n\nResponse constructor\n.\n\n\nJSON Responses\n\n\nZend\\Diactoros\\Response\\JsonResponse\n accepts a data structure to convert to JSON, and sets\nthe \nContent-Type\n header to \napplication/json\n:\n\n\n$response = new JsonResponse($data);\n\n\n\nIf providing an object, we recommend implementing \nJsonSerializable\n\nto ensure your object is correctly serialized.\n\n\nJust like the \nHtmlResponse\n, the \nJsonResponse\n allows passing two additional arguments \u2014 a\nstatus code, and an array of headers \u2014 to allow you to further seed the initial state of the\nresponse:\n\n\n$response = new JsonResponse($data, 200, [ 'Content-Type' => ['application/hal+json']]);\n\n\n\nFinally, \nJsonResponse\n allows a fourth optional argument, the flags to provide to \njson_encode()\n.\nBy default, these are set to \nJSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT\n (integer\n15), providing \nRFC 4627\n compliant JSON capable of embedding in\nHTML. If you want to specify a different set of flags, use the fourth constructor argument:\n\n\n$response = new JsonResponse(\n    $data,\n    200,\n    [],\n    JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT\n);\n\n\n\nEmpty Responses\n\n\nMany API actions allow returning empty responses:\n\n\n\n\n201 Created\n responses are often empty, and only include a \nLink\n or \nLocation\n header pointing\n  to the newly created resource.\n\n\n202 Accepted\n responses are typically empty, indicating that the new entity has been received,\n  but not yet processed.\n\n\n204 No Content\n responses are, by definition, empty, and often used as a success response when\n  deleting an entity.\n\n\n\n\nZend\\Diactoros\\Response\\EmptyResponse\n is a \nZend\\Diactoros\\Response\n extension that, by default,\nreturns an empty response with a 204 status. Its constructor allows passing the status and headers\nonly:\n\n\nclass EmptyResponse extends Response\n{\n    public function __construct($status = 204, array $headers = []);\n}\n\n\n\nAn empty, read-only body is injected at instantiation, ensuring no write operations are possible on\nthe response. Usage is typically one of the following forms:\n\n\n// Basic 204 response:\n$response = new EmptyResponse();\n\n// 201 response with location header:\n$response = new EmptyResponse(201, [\n    'Location' => [ $url ],\n]);\n\n// Alternately, set the header after instantiation:\n$response = ( new EmptyResponse(201) )->withHeader('Location', $url);\n\n\n\nRedirects\n\n\nZend\\Diactoros\\Response\\RedirectResponse\n is a \nZend\\Diactoros\\Response\n extension for producing\nredirect responses. The only required argument is a URI, which may be provided as either a string or\n\nPsr\\Http\\Message\\UriInterface\n instance. By default, the status 302 is used, and no other headers\nare produced; you may alter these via the additional optional arguments:\n\n\nclass RedirectResponse extends Response\n{\n    public function __construct($uri, $status = 302, array $headers = []);\n}\n\n\n\nTypical usage is:\n\n\n// 302 redirect:\n$response = new RedirectResponse('/user/login');\n\n// 301 redirect:\n$response = new RedirectResponse('/user/login', 301);\n\n// using a URI instance (e.g., by altering the request URI instance)\n$uri = $request->getUri();\n$response = new RedirectResponse($uri->withPath('/login'));\n\n\n\nCreating custom responses\n\n\nPHP allows constructor overloading. What this means is that constructors of extending classes can\ndefine completely different argument sets without conflicting with the parent implementation.\nConsidering that most custom response types do not need to change internal functionality, but\ninstead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to\ncreate your custom types.\n\n\nThe general pattern will be something like this:\n\n\nclass MyCustomResponse extends Response\n{\n    public function __construct($data, $status = 200, array $headers = [])\n    {\n        // - Do something with $data, and create a Stream for the body (if necessary).\n        // - Maybe set some default headers.\n\n        parent::__construct($body, $status, $headers);\n    }\n}\n\n\n\nNote the call to \nparent::__construct()\n. This is particularly relevant, as the implementation at\nthe time of writing has all class properties marked as private, making them inaccessible to\nextensions; this is done to protect encapsulation and ensure consistency of operations between\ninstances.\n\n\nIf you don't want to go the extension route (perhaps you don't want another \nResponseInterface\n\nimplementation within your object graph) you can instead create a factory. As an example:\n\n\n$plainTextResponse = function ($text, $status = 200, array $headers = []) {\n    $response = new Response('php://temp', $status, $headers);\n    $response->getBody()->write($text);\n    if (! $response->hasHeader('Content-Type')) {\n        $response = $response->withHeader('Content-Type', 'text/plain');\n    }\n    return $response;\n};\n\n$response = $plainTextResponse('Hello, world!');\n\n\n\nWe recommend following the semantic of providing the status and headers as the final two arguments\nfor any factory or custom response extensions.",
            "title": "Custom Responses"
        },
        {
            "location": "/custom-responses/#custom-responses",
            "text": "When developing server-side applications, the message type you're most likely to create manually is\nthe response. In such cases, the standard signature can be an obstacle to usability. Let's review:  class Response implements ResponseInterface\n{\n    public function __construct($body = 'php://temp', $status = 200, array $headers = []);\n}  Some standard use cases, however, make this un-wieldy:   Returning a response containing HTML; in this case, you likely want to provide the HTML to the\n  constructor, not a stream with the HTML injected.  Returning a response containing JSON; in this case, you likely want to provide the data to\n  serialize to JSON, not a stream containing serialized JSON.  Returning a response with no content; in this case, you don't want to bother with the body at all.  Returning a redirect response; in this case, you likely just want to specify the target for the\n   Location  header, and optionally the status code.   Starting with version 1.1, Diactoros offers several custom response types for simplifying these\ncommon tasks.",
            "title": "Custom Responses"
        },
        {
            "location": "/custom-responses/#text-responses",
            "text": "Zend\\Diactoros\\Response\\TextResponse  creates a plain text response. It sets the Content-Type  header to  text/plain  by default:  $response = new TextResponse('Hello world!');  The constructor accepts two additional arguments: a status code and an array of headers.  $response = new TextResponse($text, 200, ['Content-Type' => ['text/csv']]);",
            "title": "Text Responses"
        },
        {
            "location": "/custom-responses/#html-responses",
            "text": "Zend\\Diactoros\\Response\\HtmlResponse  allows specifying HTML as a payload, and sets the Content-Type  header to  text/html  by default:  $response = new HtmlResponse($htmlContent);  The constructor allows passing two additional arguments: a status code, and an array of headers.\nThese allow you to further seed the initial state of the response, as well as to override the Content-Type  header if desired:  $response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' => ['application/xhtml+xml']]);  Headers must be in the same format as you would provide to the Response constructor .",
            "title": "HTML Responses"
        },
        {
            "location": "/custom-responses/#json-responses",
            "text": "Zend\\Diactoros\\Response\\JsonResponse  accepts a data structure to convert to JSON, and sets\nthe  Content-Type  header to  application/json :  $response = new JsonResponse($data);  If providing an object, we recommend implementing  JsonSerializable \nto ensure your object is correctly serialized.  Just like the  HtmlResponse , the  JsonResponse  allows passing two additional arguments \u2014 a\nstatus code, and an array of headers \u2014 to allow you to further seed the initial state of the\nresponse:  $response = new JsonResponse($data, 200, [ 'Content-Type' => ['application/hal+json']]);  Finally,  JsonResponse  allows a fourth optional argument, the flags to provide to  json_encode() .\nBy default, these are set to  JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT  (integer\n15), providing  RFC 4627  compliant JSON capable of embedding in\nHTML. If you want to specify a different set of flags, use the fourth constructor argument:  $response = new JsonResponse(\n    $data,\n    200,\n    [],\n    JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT\n);",
            "title": "JSON Responses"
        },
        {
            "location": "/custom-responses/#empty-responses",
            "text": "Many API actions allow returning empty responses:   201 Created  responses are often empty, and only include a  Link  or  Location  header pointing\n  to the newly created resource.  202 Accepted  responses are typically empty, indicating that the new entity has been received,\n  but not yet processed.  204 No Content  responses are, by definition, empty, and often used as a success response when\n  deleting an entity.   Zend\\Diactoros\\Response\\EmptyResponse  is a  Zend\\Diactoros\\Response  extension that, by default,\nreturns an empty response with a 204 status. Its constructor allows passing the status and headers\nonly:  class EmptyResponse extends Response\n{\n    public function __construct($status = 204, array $headers = []);\n}  An empty, read-only body is injected at instantiation, ensuring no write operations are possible on\nthe response. Usage is typically one of the following forms:  // Basic 204 response:\n$response = new EmptyResponse();\n\n// 201 response with location header:\n$response = new EmptyResponse(201, [\n    'Location' => [ $url ],\n]);\n\n// Alternately, set the header after instantiation:\n$response = ( new EmptyResponse(201) )->withHeader('Location', $url);",
            "title": "Empty Responses"
        },
        {
            "location": "/custom-responses/#redirects",
            "text": "Zend\\Diactoros\\Response\\RedirectResponse  is a  Zend\\Diactoros\\Response  extension for producing\nredirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface  instance. By default, the status 302 is used, and no other headers\nare produced; you may alter these via the additional optional arguments:  class RedirectResponse extends Response\n{\n    public function __construct($uri, $status = 302, array $headers = []);\n}  Typical usage is:  // 302 redirect:\n$response = new RedirectResponse('/user/login');\n\n// 301 redirect:\n$response = new RedirectResponse('/user/login', 301);\n\n// using a URI instance (e.g., by altering the request URI instance)\n$uri = $request->getUri();\n$response = new RedirectResponse($uri->withPath('/login'));",
            "title": "Redirects"
        },
        {
            "location": "/custom-responses/#creating-custom-responses",
            "text": "PHP allows constructor overloading. What this means is that constructors of extending classes can\ndefine completely different argument sets without conflicting with the parent implementation.\nConsidering that most custom response types do not need to change internal functionality, but\ninstead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to\ncreate your custom types.  The general pattern will be something like this:  class MyCustomResponse extends Response\n{\n    public function __construct($data, $status = 200, array $headers = [])\n    {\n        // - Do something with $data, and create a Stream for the body (if necessary).\n        // - Maybe set some default headers.\n\n        parent::__construct($body, $status, $headers);\n    }\n}  Note the call to  parent::__construct() . This is particularly relevant, as the implementation at\nthe time of writing has all class properties marked as private, making them inaccessible to\nextensions; this is done to protect encapsulation and ensure consistency of operations between\ninstances.  If you don't want to go the extension route (perhaps you don't want another  ResponseInterface \nimplementation within your object graph) you can instead create a factory. As an example:  $plainTextResponse = function ($text, $status = 200, array $headers = []) {\n    $response = new Response('php://temp', $status, $headers);\n    $response->getBody()->write($text);\n    if (! $response->hasHeader('Content-Type')) {\n        $response = $response->withHeader('Content-Type', 'text/plain');\n    }\n    return $response;\n};\n\n$response = $plainTextResponse('Hello, world!');  We recommend following the semantic of providing the status and headers as the final two arguments\nfor any factory or custom response extensions.",
            "title": "Creating custom responses"
        },
        {
            "location": "/emitting-responses/",
            "text": "Emitting responses\n\n\nIf you are using a non-SAPI PHP implementation and wish to use the \nServer\n class, or if you do not\nwant to use the \nServer\n implementation but want to emit a response, this package provides an\ninterface, \nZend\\Diactoros\\Response\\EmitterInterface\n, defining a method \nemit()\n for emitting the\nresponse. A single implementation is currently available, \nZend\\Diactoros\\Response\\SapiEmitter\n,\nwhich will use the native PHP functions \nheader()\n and \necho\n in order to emit the response. If you\nare using a non-SAPI implementation, you will need to create your own \nEmitterInterface\n\nimplementation.\n\n\nFor example, the \nSapiEmitter\n implementation of the \nEmitterInterface\n can be used thus:\n\n\n$response = new Zend\\Diactoros\\Response();\n$response->getBody()->write(\"some content\\n\");\n$emitter = new Zend\\Diactoros\\Response\\SapiEmitter();\n$emitter->emit($response);",
            "title": "Emitting Responses"
        },
        {
            "location": "/emitting-responses/#emitting-responses",
            "text": "If you are using a non-SAPI PHP implementation and wish to use the  Server  class, or if you do not\nwant to use the  Server  implementation but want to emit a response, this package provides an\ninterface,  Zend\\Diactoros\\Response\\EmitterInterface , defining a method  emit()  for emitting the\nresponse. A single implementation is currently available,  Zend\\Diactoros\\Response\\SapiEmitter ,\nwhich will use the native PHP functions  header()  and  echo  in order to emit the response. If you\nare using a non-SAPI implementation, you will need to create your own  EmitterInterface \nimplementation.  For example, the  SapiEmitter  implementation of the  EmitterInterface  can be used thus:  $response = new Zend\\Diactoros\\Response();\n$response->getBody()->write(\"some content\\n\");\n$emitter = new Zend\\Diactoros\\Response\\SapiEmitter();\n$emitter->emit($response);",
            "title": "Emitting responses"
        },
        {
            "location": "/serialization/",
            "text": "Serialization\n\n\nString\n\n\nAt times, it's useful to either create a string representation of a message (serialization), or to\ncast a string or stream message to an object (deserialization). This package provides features for\nthis in \nZend\\Diactoros\\Request\\Serializer\n and \nZend\\Diactoros\\Response\\Serializer\n; each provides\nthe following static methods:\n\n\n\n\nfromString($message)\n will create either a \nRequest\n or \nResponse\n instance (based on the\n  serializer used) from the string message.\n\n\nfromStream(Psr\\Http\\Message\\StreamInterface $stream)\n will create either a \nRequest\n or\n  \nResponse\n instance (based on the serializer used) from the provided stream.\n\n\ntoString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)\n will\n  create either a string from the provided message.\n\n\n\n\nThe deserialization methods (\nfrom*()\n) will raise exceptions if errors occur while parsing the\nmessage. The serialization methods (\ntoString()\n) will raise exceptions if required data for\nserialization is not present in the message instance.\n\n\nArray\n\n\nThis package also provides features for array serialization using\n\nZend\\Diactoros\\Request\\ArraySerializer\n and \nZend\\Diactoros\\Response\\ArraySerializer\n; each provides\nthe following static methods:\n\n\n\n\nfromArray(array $message)\n will create either a \nRequest\n or \nResponse\n instance (based on the\n  serializer used) from the array message.\n\n\ntoArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)\n will\n  create an array from the provided message.\n\n\n\n\nThe deserialization methods (\nfromArray()\n) will raise exceptions if errors occur while parsing the\nmessage.\n\n\nExample usage\n\n\nArray serialization can be usesful for log messages:\n\n\nclass LoggerMiddleware\n{\n    /**\n     * @var \\Psr\\Log\\LoggerInterface\n     */\n    protected $logger;\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $response = $next($request, $response);\n\n        $this->logger->debug('Request/Response', [\n            'request' => \\Zend\\Diactoros\\Request\\ArraySerializer::toArray($request),\n            'response' => \\Zend\\Diactoros\\Response\\ArraySerializer::toArray($response),\n        ]);\n\n        return $response;\n    }\n}",
            "title": "Serialization"
        },
        {
            "location": "/serialization/#serialization",
            "text": "",
            "title": "Serialization"
        },
        {
            "location": "/serialization/#string",
            "text": "At times, it's useful to either create a string representation of a message (serialization), or to\ncast a string or stream message to an object (deserialization). This package provides features for\nthis in  Zend\\Diactoros\\Request\\Serializer  and  Zend\\Diactoros\\Response\\Serializer ; each provides\nthe following static methods:   fromString($message)  will create either a  Request  or  Response  instance (based on the\n  serializer used) from the string message.  fromStream(Psr\\Http\\Message\\StreamInterface $stream)  will create either a  Request  or\n   Response  instance (based on the serializer used) from the provided stream.  toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)  will\n  create either a string from the provided message.   The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the\nmessage. The serialization methods ( toString() ) will raise exceptions if required data for\nserialization is not present in the message instance.",
            "title": "String"
        },
        {
            "location": "/serialization/#array",
            "text": "This package also provides features for array serialization using Zend\\Diactoros\\Request\\ArraySerializer  and  Zend\\Diactoros\\Response\\ArraySerializer ; each provides\nthe following static methods:   fromArray(array $message)  will create either a  Request  or  Response  instance (based on the\n  serializer used) from the array message.  toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)  will\n  create an array from the provided message.   The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the\nmessage.",
            "title": "Array"
        },
        {
            "location": "/serialization/#example-usage",
            "text": "Array serialization can be usesful for log messages:  class LoggerMiddleware\n{\n    /**\n     * @var \\Psr\\Log\\LoggerInterface\n     */\n    protected $logger;\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $response = $next($request, $response);\n\n        $this->logger->debug('Request/Response', [\n            'request' => \\Zend\\Diactoros\\Request\\ArraySerializer::toArray($request),\n            'response' => \\Zend\\Diactoros\\Response\\ArraySerializer::toArray($response),\n        ]);\n\n        return $response;\n    }\n}",
            "title": "Example usage"
        },
        {
            "location": "/api/",
            "text": "API\n\n\nRequest Message\n\n\nZend\\Diactoros\\Request\n implements \nPsr\\Http\\Message\\RequestInterface\n,\nand is intended for client-side requests. It includes the following methods:\n\n\nclass Request\n{\n    public function __construct(\n        $uri = null,\n        $method = null,\n        $body = 'php://memory',\n        array $headers = []\n    );\n\n    // See psr/http-message's RequestInterface for other methods\n}\n\n\n\nRequests are immutable. Any methods that would change state \u2014 those prefixed with \nwith\n and\n\nwithout\n \u2014 all return a new instance with the changes requested.\n\n\nServerRequest Message\n\n\nFor server-side applications, \nZend\\Diactoros\\ServerRequest\n implements\n\nPsr\\Http\\Message\\ServerRequestInterface\n,\nwhich provides access to the elements of an HTTP request, as well as uniform access to the various\nelements of incoming data. The methods included are:\n\n\nclass ServerRequest\n{\n    public function __construct(\n        array $serverParams = [],\n        array $fileParams = [],\n        $uri = null,\n        $method = null,\n        $body = 'php://input',\n        array $headers = []\n    );\n\n    // See psr/http-message's ServerRequestInterface for other methods.\n}\n\n\n\nThe \nServerRequest\n is immutable. Any methods that would change state \u2014 those prefixed with \nwith\n\nand \nwithout\n \u2014 all return a new instance with the changes requested. Server parameters are\nconsidered completely immutable, however, as they cannot be recalculated, and, rather, is a source\nfor other values.\n\n\nResponse Message\n\n\nZend\\Diactoros\\Response\n provides an implementation of\n\nPsr\\Http\\Message\\ResponseInterface\n,\nan object to be used to aggregate response information for both HTTP clients and server-side\napplications, including headers and message body content. It includes the following:\n\n\nclass Response\n{\n    public function __construct(\n        $body = 'php://memory',\n        $statusCode = 200,\n        array $headers = []\n    );\n\n    // See psr/http-message's ResponseInterface for other methods\n}\n\n\n\nLike the \nRequest\n and \nServerRequest\n, responses are immutable. Any methods that would change state\n\u2014 those prefixed with \nwith\n and \nwithout\n \u2014 all return a new instance with the changes requested.\n\n\nStringResponse (factory)\n\n\n\n\nAdded in 1.1.0\n\n\n\n\nThe most common use case in server-side applications for generating responses is to provide a string\nto use for the response, typically HTML or data to serialize as JSON.  \nZend\\Diactoros\\Response\\StringResponse\n\nexists to facilitate these use cases:\n\n\n$htmlResponse = StringResponse::html($html);\n\n$jsonResponse = StringResponse::json($data);\n\n\n\nIn the first example, you will receive a response with a stream containing the HTML; additionally,\nthe \nContent-Type\n header will be set to \ntext/html\n. In the second case, the stream will contain a\nstream containing the JSON-serialized \n$data\n, and have a \nContent-Type\n header set to\n\napplication/json\n.\n\n\nBoth factory methods allow passing the HTTP status, as well as any headers you want to specify,\nincluding the \nContent-Type\n header:\n\n\n$htmlResponse = StringResponse::html($html, 404, [\n    'Content-Type' => [ 'application/xhtml+xml' ],\n]);\n\n$jsonResponse = StringResponse::json($data, 422, [\n    'Content-Type' => [ 'application/problem+json' ],\n]);\n\n\n\nServerRequestFactory\n\n\nThis static class can be used to marshal a \nServerRequest\n instance from the PHP environment. The\nprimary entry point is \nZend\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array\n$query, array $body, array $cookies, array $files)\n. This method will create a new \nServerRequest\n\ninstance with the data provided. Examples of usage are:\n\n\n// Returns new ServerRequest instance, using values from superglobals:\n$request = ServerRequestFactory::fromGlobals();\n\n// or\n\n// Returns new ServerRequest instance, using values provided (in this\n// case, equivalent to the previous!)\n$request = RequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);\n\n\n\nURI\n\n\nZend\\Diactoros\\Uri\n is an implementation of\n\nPsr\\Http\\Message\\UriInterface\n,\nand models and validates URIs. It implements \n__toString()\n, allowing it to be represented as a\nstring and \necho()\n'd directly. The following methods are pertinent:\n\n\nclass Uri\n{\n    public function __construct($uri = '');\n\n    // See psr/http-message's UriInterface for other methods.\n}\n\n\n\nLike the various message objects, URIs are immutable. Any methods that would\nchange state \u2014 those\nprefixed with \nwith\n and \nwithout\n \u2014 all return a new instance with the changes requested.\n\n\nStream\n\n\nZend\\Diactoros\\Stream\n is an implementation of\n\nPsr\\Http\\Message\\StreamInterface\n,\nand provides a number of facilities around manipulating the composed PHP stream resource. The\nconstructor accepts a stream, which may be either:\n\n\n\n\na stream identifier; e.g., \nphp://input\n, a filename, etc.\n\n\na PHP stream resource\n\n\n\n\nIf a stream identifier is provided, an optional second parameter may be provided, the file mode by\nwhich to \nfopen\n the stream.\n\n\nServerRequest\n objects by default use a \nphp://input\n stream set to read-only; \nResponse\n objects\nby default use a \nphp://memory\n with a mode of \nwb+\n, allowing binary read/write access.\n\n\nIn most cases, you will not interact with the Stream object directly.\n\n\nUploadedFile\n\n\nZend\\Diactoros\\UploadedFile\n is an implementation of\n\nPsr\\Http\\Message\\UploadedFileInterface\n,\nand provides abstraction around a single uploaded file, including behavior for interacting with it\nas a stream or moving it to a filesystem location.\n\n\nIn most cases, you will only use the methods defined in the \nUploadedFileInterface\n.\n\n\nServer\n\n\nZend\\Diactoros\\Server\n represents a server capable of executing a callback. It has four methods:\n\n\nclass Server\n{\n    public function __construct(\n        callable $callback,\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    );\n    public static function createServer(\n        callable $callback,\n        array $server,  // usually $_SERVER\n        array $query,   // usually $_GET\n        array $body,    // usually $_POST\n        array $cookies, // usually $_COOKIE\n        array $files    // usually $_FILES\n    );\n    public static function createServerFromRequest(\n        callable $callback,\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response = null\n    );\n    public function setEmitter(Response\\EmitterInterface $emitter);\n    public function listen(callable $finalHandler = null);\n}\n\n\n\nYou can create an instance of the \nServer\n using any of the constructor, \ncreateServer()\n, or\n\ncreateServerFromRequest()\n methods. If you wish to use the default request and response\nimplementations, \ncreateServer($middleware, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES)\n is the\nrecommended option, as this method will also marshal the \nServerRequest\n object based on the PHP\nrequest environment.  If you wish to use your own implementations, pass them to the constructor or\n\ncreateServerFromRequest()\n method (the latter will create a default \nResponse\n instance if you omit\nit).\n\n\nlisten()\n executes the callback. If a \n$finalHandler\n is provided, it will be passed as the third\nargument to the \n$callback\n registered with the server.",
            "title": "API"
        },
        {
            "location": "/api/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/api/#request-message",
            "text": "Zend\\Diactoros\\Request  implements  Psr\\Http\\Message\\RequestInterface ,\nand is intended for client-side requests. It includes the following methods:  class Request\n{\n    public function __construct(\n        $uri = null,\n        $method = null,\n        $body = 'php://memory',\n        array $headers = []\n    );\n\n    // See psr/http-message's RequestInterface for other methods\n}  Requests are immutable. Any methods that would change state \u2014 those prefixed with  with  and without  \u2014 all return a new instance with the changes requested.",
            "title": "Request Message"
        },
        {
            "location": "/api/#serverrequest-message",
            "text": "For server-side applications,  Zend\\Diactoros\\ServerRequest  implements Psr\\Http\\Message\\ServerRequestInterface ,\nwhich provides access to the elements of an HTTP request, as well as uniform access to the various\nelements of incoming data. The methods included are:  class ServerRequest\n{\n    public function __construct(\n        array $serverParams = [],\n        array $fileParams = [],\n        $uri = null,\n        $method = null,\n        $body = 'php://input',\n        array $headers = []\n    );\n\n    // See psr/http-message's ServerRequestInterface for other methods.\n}  The  ServerRequest  is immutable. Any methods that would change state \u2014 those prefixed with  with \nand  without  \u2014 all return a new instance with the changes requested. Server parameters are\nconsidered completely immutable, however, as they cannot be recalculated, and, rather, is a source\nfor other values.",
            "title": "ServerRequest Message"
        },
        {
            "location": "/api/#response-message",
            "text": "Zend\\Diactoros\\Response  provides an implementation of Psr\\Http\\Message\\ResponseInterface ,\nan object to be used to aggregate response information for both HTTP clients and server-side\napplications, including headers and message body content. It includes the following:  class Response\n{\n    public function __construct(\n        $body = 'php://memory',\n        $statusCode = 200,\n        array $headers = []\n    );\n\n    // See psr/http-message's ResponseInterface for other methods\n}  Like the  Request  and  ServerRequest , responses are immutable. Any methods that would change state\n\u2014 those prefixed with  with  and  without  \u2014 all return a new instance with the changes requested.",
            "title": "Response Message"
        },
        {
            "location": "/api/#stringresponse-factory",
            "text": "Added in 1.1.0   The most common use case in server-side applications for generating responses is to provide a string\nto use for the response, typically HTML or data to serialize as JSON.   Zend\\Diactoros\\Response\\StringResponse \nexists to facilitate these use cases:  $htmlResponse = StringResponse::html($html);\n\n$jsonResponse = StringResponse::json($data);  In the first example, you will receive a response with a stream containing the HTML; additionally,\nthe  Content-Type  header will be set to  text/html . In the second case, the stream will contain a\nstream containing the JSON-serialized  $data , and have a  Content-Type  header set to application/json .  Both factory methods allow passing the HTTP status, as well as any headers you want to specify,\nincluding the  Content-Type  header:  $htmlResponse = StringResponse::html($html, 404, [\n    'Content-Type' => [ 'application/xhtml+xml' ],\n]);\n\n$jsonResponse = StringResponse::json($data, 422, [\n    'Content-Type' => [ 'application/problem+json' ],\n]);",
            "title": "StringResponse (factory)"
        },
        {
            "location": "/api/#serverrequestfactory",
            "text": "This static class can be used to marshal a  ServerRequest  instance from the PHP environment. The\nprimary entry point is  Zend\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array\n$query, array $body, array $cookies, array $files) . This method will create a new  ServerRequest \ninstance with the data provided. Examples of usage are:  // Returns new ServerRequest instance, using values from superglobals:\n$request = ServerRequestFactory::fromGlobals();\n\n// or\n\n// Returns new ServerRequest instance, using values provided (in this\n// case, equivalent to the previous!)\n$request = RequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);",
            "title": "ServerRequestFactory"
        },
        {
            "location": "/api/#uri",
            "text": "Zend\\Diactoros\\Uri  is an implementation of Psr\\Http\\Message\\UriInterface ,\nand models and validates URIs. It implements  __toString() , allowing it to be represented as a\nstring and  echo() 'd directly. The following methods are pertinent:  class Uri\n{\n    public function __construct($uri = '');\n\n    // See psr/http-message's UriInterface for other methods.\n}  Like the various message objects, URIs are immutable. Any methods that would\nchange state \u2014 those\nprefixed with  with  and  without  \u2014 all return a new instance with the changes requested.",
            "title": "URI"
        },
        {
            "location": "/api/#stream",
            "text": "Zend\\Diactoros\\Stream  is an implementation of Psr\\Http\\Message\\StreamInterface ,\nand provides a number of facilities around manipulating the composed PHP stream resource. The\nconstructor accepts a stream, which may be either:   a stream identifier; e.g.,  php://input , a filename, etc.  a PHP stream resource   If a stream identifier is provided, an optional second parameter may be provided, the file mode by\nwhich to  fopen  the stream.  ServerRequest  objects by default use a  php://input  stream set to read-only;  Response  objects\nby default use a  php://memory  with a mode of  wb+ , allowing binary read/write access.  In most cases, you will not interact with the Stream object directly.",
            "title": "Stream"
        },
        {
            "location": "/api/#uploadedfile",
            "text": "Zend\\Diactoros\\UploadedFile  is an implementation of Psr\\Http\\Message\\UploadedFileInterface ,\nand provides abstraction around a single uploaded file, including behavior for interacting with it\nas a stream or moving it to a filesystem location.  In most cases, you will only use the methods defined in the  UploadedFileInterface .",
            "title": "UploadedFile"
        },
        {
            "location": "/api/#server",
            "text": "Zend\\Diactoros\\Server  represents a server capable of executing a callback. It has four methods:  class Server\n{\n    public function __construct(\n        callable $callback,\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    );\n    public static function createServer(\n        callable $callback,\n        array $server,  // usually $_SERVER\n        array $query,   // usually $_GET\n        array $body,    // usually $_POST\n        array $cookies, // usually $_COOKIE\n        array $files    // usually $_FILES\n    );\n    public static function createServerFromRequest(\n        callable $callback,\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response = null\n    );\n    public function setEmitter(Response\\EmitterInterface $emitter);\n    public function listen(callable $finalHandler = null);\n}  You can create an instance of the  Server  using any of the constructor,  createServer() , or createServerFromRequest()  methods. If you wish to use the default request and response\nimplementations,  createServer($middleware, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES)  is the\nrecommended option, as this method will also marshal the  ServerRequest  object based on the PHP\nrequest environment.  If you wish to use your own implementations, pass them to the constructor or createServerFromRequest()  method (the latter will create a default  Response  instance if you omit\nit).  listen()  executes the callback. If a  $finalHandler  is provided, it will be passed as the third\nargument to the  $callback  registered with the server.",
            "title": "Server"
        }
    ]
}