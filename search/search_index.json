{
    "docs": [
        {
            "location": "/",
            "text": "zend-diactoros\n\n\nMaster:\n\n\n\n\nDevelop:\n\n\n\n\n\n\n\nDiactoros (pronunciation: \n/d\u026a\u028ckt\u0252r\u0252s/\n): an epithet for Hermes, meaning literally, \"the messenger.\"\n\n\n\n\nThis package supercedes and replaces \nphly/http\n.\n\n\nzend-diactoros\n is a PHP package containing implementations of the\n\nPSR-7 HTTP message interfaces\n\nand \nPSR-17 HTTP message factory interfaces\n.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-diactoros/issues\n\n\nIssue patches to https://github.com/zendframework/zend-diactoros/pulls\n\n\n\n\nDocumentation\n\n\nDocumentation is available at:\n\n\n\n\nhttps://docs.zendframework.com/zend-diactoros/\n\n\n\n\nSource files for documentation are \nin the docs/ tree\n.",
            "title": "zend-diactoros"
        },
        {
            "location": "/#zend-diactoros",
            "text": "Master:  \nDevelop:    Diactoros (pronunciation:  /d\u026a\u028ckt\u0252r\u0252s/ ): an epithet for Hermes, meaning literally, \"the messenger.\"   This package supercedes and replaces  phly/http .  zend-diactoros  is a PHP package containing implementations of the PSR-7 HTTP message interfaces \nand  PSR-17 HTTP message factory interfaces .   File issues at https://github.com/zendframework/zend-diactoros/issues  Issue patches to https://github.com/zendframework/zend-diactoros/pulls",
            "title": "zend-diactoros"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is available at:   https://docs.zendframework.com/zend-diactoros/   Source files for documentation are  in the docs/ tree .",
            "title": "Documentation"
        },
        {
            "location": "/v2/overview/",
            "text": "zend-diactoros: HTTP Messages\n\n\nzend-diactoros\n is a PHP package containing implementations of the\n\nPSR-7 HTTP message interfaces\n,\nas well as the \nPSR-17 HTTP message factory interfaces\n.",
            "title": "Overview"
        },
        {
            "location": "/v2/overview/#zend-diactoros-http-messages",
            "text": "zend-diactoros  is a PHP package containing implementations of the PSR-7 HTTP message interfaces ,\nas well as the  PSR-17 HTTP message factory interfaces .",
            "title": "zend-diactoros: HTTP Messages"
        },
        {
            "location": "/v2/install/",
            "text": "Installation and Requirements\n\n\nInstall this library using composer:\n\n\n$ composer require zendframework/zend-diactoros\n\n\n\nzend-diactoros\n has the following dependencies (which are managed by Composer):\n\n\n\n\n\n\npsr/http-message\n, which defines interfaces for HTTP messages, including requests and responses.\n  \nzend-diactoros\n provides implementations of each of these.\n\n\n\n\n\n\npsr/http-factory\n, which defines interfaces for HTTP message factories.\n  \nzend-diactoros\n provides implementations of each of these.",
            "title": "Installation"
        },
        {
            "location": "/v2/install/#installation-and-requirements",
            "text": "Install this library using composer:  $ composer require zendframework/zend-diactoros  zend-diactoros  has the following dependencies (which are managed by Composer):    psr/http-message , which defines interfaces for HTTP messages, including requests and responses.\n   zend-diactoros  provides implementations of each of these.    psr/http-factory , which defines interfaces for HTTP message factories.\n   zend-diactoros  provides implementations of each of these.",
            "title": "Installation and Requirements"
        },
        {
            "location": "/v2/usage/",
            "text": "Usage\n\n\nUsage will differ based on whether you are writing an HTTP client, or a server-side application.\n\n\nFor HTTP client purposes, you will create and populate a \nRequest\n instance, and the client should\nreturn a \nResponse\n instance.\n\n\nFor server-side applications, you will create a \nServerRequest\n instance, and populate and return a\n\nResponse\n instance.\n\n\nHTTP Clients\n\n\nA client will \nsend\n a request, and \nreturn\n a response. As a developer, you will \ncreate\n and\n\npopulate\n the request, and then \nintrospect\n the response.  Both requests and responses are\nimmutable; if you make changes \u2014 e.g., by calling setter methods \u2014 you must capture the return\nvalue, as it is a new instance.\n\n\n// Create a request\n$request = (new Zend\\Diactoros\\Request())\n    ->withUri(new Zend\\Diactoros\\Uri('http://example.com'))\n    ->withMethod('PATCH')\n    ->withAddedHeader('Authorization', 'Bearer ' . $token)\n    ->withAddedHeader('Content-Type', 'application/json');\n\n// OR:\n$request = new Zend\\Diactoros\\Request(\n    'http://example.com',\n    'PATCH',\n    'php://memory',\n    [\n        'Authorization' => 'Bearer ' . $token,\n        'Content-Type'  => 'application/json',\n    ]\n);\n\n// If you want to set a non-origin-form request target, set the\n// request-target explicitly:\n$request = $request->withRequestTarget((string) $uri);       // absolute-form\n$request = $request->withRequestTarget($uri->getAuthority()); // authority-form\n$request = $request->withRequestTarget('*');                 // asterisk-form\n\n// Once you have the instance:\n$request->getBody()->write(json_encode($data));\n$response = $client->send($request);\n\nprintf(\"Response status: %d (%s)\\n\", $response->getStatusCode(), $response->getReasonPhrase());\nprintf(\"Headers:\\n\");\nforeach ($response->getHeaders() as $header => $values) {\n    printf(\"    %s: %s\\n\", $header, implode(', ', $values));\n}\nprintf(\"Message:\\n%s\\n\", $response->getBody());\n\n\n\n(Note: \nzend-diactoros\n does NOT ship with a client implementation; the above is just an\nillustration of a possible implementation.)\n\n\nServer-Side Applications\n\n\nServer-side applications will need to marshal the incoming request based on superglobals, and will\nthen populate and send a response.\n\n\nMarshaling an incoming request\n\n\nPHP contains a plethora of information about the incoming request, and keeps that information in a\nvariety of locations. \nZend\\Diactoros\\ServerRequestFactory::fromGlobals()\n can simplify marshaling\nthat information into a request instance.\n\n\nYou can call the factory method with or without the following arguments, in the following order:\n\n\n\n\n$server\n, typically \n$_SERVER\n\n\n$query\n, typically \n$_GET\n\n\n$body\n, typically \n$_POST\n\n\n$cookies\n, typically \n$_COOKIE\n\n\n$files\n, typically \n$_FILES\n\n\n\n\nThe method will then return a \nZend\\Diactoros\\ServerRequest\n instance. If any argument is omitted,\nthe associated superglobal will be used.\n\n\n$request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);\n\n\n\nWhen no cookie array is supplied, \nfromGlobals\n will first try to parse the supplied \ncookie\n header\nbefore falling back to the \n$_COOKIE\n superglobal. This is done because PHP has some legacy handling\nfor request parameters which were then registered as global variables. Due to this, cookies with a period\nin the name were renamed with underlines. By getting the cookies directly from the cookie header, you have\naccess to the original cookies in the way you set them in your application and they are send by the user\nagent.\n\n\nManipulating the response\n\n\nUse the response object to add headers and provide content for the response.  Writing to the body\ndoes not create a state change in the response, so it can be done without capturing the return\nvalue. Manipulating headers does, however.\n\n\n$response = new Zend\\Diactoros\\Response();\n\n// Write to the response body:\n$response->getBody()->write(\"some content\\n\");\n\n// Multiple calls to write() append:\n$response->getBody()->write(\"more content\\n\"); // now \"some content\\nmore content\\n\"\n\n// Add headers\n// Note: headers do not need to be added before data is written to the body!\n$response = $response\n    ->withHeader('Content-Type', 'text/plain')\n    ->withAddedHeader('X-Show-Something', 'something');",
            "title": "Usage"
        },
        {
            "location": "/v2/usage/#usage",
            "text": "Usage will differ based on whether you are writing an HTTP client, or a server-side application.  For HTTP client purposes, you will create and populate a  Request  instance, and the client should\nreturn a  Response  instance.  For server-side applications, you will create a  ServerRequest  instance, and populate and return a Response  instance.",
            "title": "Usage"
        },
        {
            "location": "/v2/usage/#http-clients",
            "text": "A client will  send  a request, and  return  a response. As a developer, you will  create  and populate  the request, and then  introspect  the response.  Both requests and responses are\nimmutable; if you make changes \u2014 e.g., by calling setter methods \u2014 you must capture the return\nvalue, as it is a new instance.  // Create a request\n$request = (new Zend\\Diactoros\\Request())\n    ->withUri(new Zend\\Diactoros\\Uri('http://example.com'))\n    ->withMethod('PATCH')\n    ->withAddedHeader('Authorization', 'Bearer ' . $token)\n    ->withAddedHeader('Content-Type', 'application/json');\n\n// OR:\n$request = new Zend\\Diactoros\\Request(\n    'http://example.com',\n    'PATCH',\n    'php://memory',\n    [\n        'Authorization' => 'Bearer ' . $token,\n        'Content-Type'  => 'application/json',\n    ]\n);\n\n// If you want to set a non-origin-form request target, set the\n// request-target explicitly:\n$request = $request->withRequestTarget((string) $uri);       // absolute-form\n$request = $request->withRequestTarget($uri->getAuthority()); // authority-form\n$request = $request->withRequestTarget('*');                 // asterisk-form\n\n// Once you have the instance:\n$request->getBody()->write(json_encode($data));\n$response = $client->send($request);\n\nprintf(\"Response status: %d (%s)\\n\", $response->getStatusCode(), $response->getReasonPhrase());\nprintf(\"Headers:\\n\");\nforeach ($response->getHeaders() as $header => $values) {\n    printf(\"    %s: %s\\n\", $header, implode(', ', $values));\n}\nprintf(\"Message:\\n%s\\n\", $response->getBody());  (Note:  zend-diactoros  does NOT ship with a client implementation; the above is just an\nillustration of a possible implementation.)",
            "title": "HTTP Clients"
        },
        {
            "location": "/v2/usage/#server-side-applications",
            "text": "Server-side applications will need to marshal the incoming request based on superglobals, and will\nthen populate and send a response.",
            "title": "Server-Side Applications"
        },
        {
            "location": "/v2/usage/#marshaling-an-incoming-request",
            "text": "PHP contains a plethora of information about the incoming request, and keeps that information in a\nvariety of locations.  Zend\\Diactoros\\ServerRequestFactory::fromGlobals()  can simplify marshaling\nthat information into a request instance.  You can call the factory method with or without the following arguments, in the following order:   $server , typically  $_SERVER  $query , typically  $_GET  $body , typically  $_POST  $cookies , typically  $_COOKIE  $files , typically  $_FILES   The method will then return a  Zend\\Diactoros\\ServerRequest  instance. If any argument is omitted,\nthe associated superglobal will be used.  $request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);  When no cookie array is supplied,  fromGlobals  will first try to parse the supplied  cookie  header\nbefore falling back to the  $_COOKIE  superglobal. This is done because PHP has some legacy handling\nfor request parameters which were then registered as global variables. Due to this, cookies with a period\nin the name were renamed with underlines. By getting the cookies directly from the cookie header, you have\naccess to the original cookies in the way you set them in your application and they are send by the user\nagent.",
            "title": "Marshaling an incoming request"
        },
        {
            "location": "/v2/usage/#manipulating-the-response",
            "text": "Use the response object to add headers and provide content for the response.  Writing to the body\ndoes not create a state change in the response, so it can be done without capturing the return\nvalue. Manipulating headers does, however.  $response = new Zend\\Diactoros\\Response();\n\n// Write to the response body:\n$response->getBody()->write(\"some content\\n\");\n\n// Multiple calls to write() append:\n$response->getBody()->write(\"more content\\n\"); // now \"some content\\nmore content\\n\"\n\n// Add headers\n// Note: headers do not need to be added before data is written to the body!\n$response = $response\n    ->withHeader('Content-Type', 'text/plain')\n    ->withAddedHeader('X-Show-Something', 'something');",
            "title": "Manipulating the response"
        },
        {
            "location": "/v2/factories/",
            "text": "HTTP Message Factories\n\n\nPSR-17\n defines factory interfaces for\ncreating \nPSR-7\n instances. As of version\n2.0.0, Diactoros supplies implementations of each as follows:\n\n\n\n\nZend\\Diactoros\\RequestFactory\n\n\nZend\\Diactoros\\ResponseFactory\n\n\nZend\\Diactoros\\ServerRequestFactory\n\n\nZend\\Diactoros\\StreamFactory\n\n\nZend\\Diactoros\\UploadedFileFactory\n\n\nZend\\Diactoros\\UriFactory\n\n\n\n\nThe \nServerRequestFactory\n continues to define the static method\n\nfromGlobals()\n, but also serves as a PSR-17 implementation.\n\n\nThese classes may be used as described in the specification document for the\npurpose of creating Diactoros instances that fulfill PSR-7 typehints.",
            "title": "Factories"
        },
        {
            "location": "/v2/factories/#http-message-factories",
            "text": "PSR-17  defines factory interfaces for\ncreating  PSR-7  instances. As of version\n2.0.0, Diactoros supplies implementations of each as follows:   Zend\\Diactoros\\RequestFactory  Zend\\Diactoros\\ResponseFactory  Zend\\Diactoros\\ServerRequestFactory  Zend\\Diactoros\\StreamFactory  Zend\\Diactoros\\UploadedFileFactory  Zend\\Diactoros\\UriFactory   The  ServerRequestFactory  continues to define the static method fromGlobals() , but also serves as a PSR-17 implementation.  These classes may be used as described in the specification document for the\npurpose of creating Diactoros instances that fulfill PSR-7 typehints.",
            "title": "HTTP Message Factories"
        },
        {
            "location": "/v2/custom-responses/",
            "text": "Custom Responses\n\n\nWhen developing server-side applications, the message type you're most likely to create manually is\nthe response. In such cases, the standard signature can be an obstacle to usability. Let's review:\n\n\nclass Response implements ResponseInterface\n{\n    public function __construct($body = 'php://temp', $status = 200, array $headers = []);\n}\n\n\n\nSome standard use cases, however, make this un-wieldy:\n\n\n\n\nReturning a response containing HTML; in this case, you likely want to provide the HTML to the\n  constructor, not a stream with the HTML injected.\n\n\nReturning a response containing JSON; in this case, you likely want to provide the data to\n  serialize to JSON, not a stream containing serialized JSON.\n\n\nReturning a response with no content; in this case, you don't want to bother with the body at all.\n\n\nReturning a redirect response; in this case, you likely just want to specify the target for the\n  \nLocation\n header, and optionally the status code.\n\n\n\n\nStarting with version 1.1, Diactoros offers several custom response types for simplifying these\ncommon tasks.\n\n\nText Responses\n\n\nZend\\Diactoros\\Response\\TextResponse\n creates a plain text response. It sets the\n\nContent-Type\n header to \ntext/plain\n by default:\n\n\n$response = new TextResponse('Hello world!');\n\n\n\nThe constructor accepts two additional arguments: a status code and an array of headers.\n\n\n$response = new TextResponse($text, 200, ['Content-Type' => ['text/csv']]);\n\n\n\nHTML Responses\n\n\nZend\\Diactoros\\Response\\HtmlResponse\n allows specifying HTML as a payload, and sets the\n\nContent-Type\n header to \ntext/html\n by default:\n\n\n$response = new HtmlResponse($htmlContent);\n\n\n\nThe constructor allows passing two additional arguments: a status code, and an array of headers.\nThese allow you to further seed the initial state of the response, as well as to override the\n\nContent-Type\n header if desired:\n\n\n$response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' => ['application/xhtml+xml']]);\n\n\n\nHeaders must be in the same format as you would provide to the\n\nResponse constructor\n.\n\n\nXML Responses\n\n\nZend\\Diactoros\\Response\\XmlResponse\n allows specifying XML as a payload, and sets the\n\nContent-Type\n header to \napplication/xml\n by default:\n\n\n$response = new XmlResponse($xml);\n\n\n\nThe constructor allows passing two additional arguments: a status code, and an array of headers.\nThese allow you to further seed the initial state of the response, as well as to override the\n\nContent-Type\n header if desired:\n\n\n$response = new XmlResponse($xml, 200, [ 'Content-Type' => ['application/hal+xml']]);\n\n\n\nHeaders must be in the same format as you would provide to the\n\nResponse constructor\n.\n\n\nJSON Responses\n\n\nZend\\Diactoros\\Response\\JsonResponse\n accepts a data structure to convert to JSON, and sets\nthe \nContent-Type\n header to \napplication/json\n:\n\n\n$response = new JsonResponse($data);\n\n\n\nIf providing an object, we recommend implementing \nJsonSerializable\n\nto ensure your object is correctly serialized.\n\n\nJust like the \nHtmlResponse\n, the \nJsonResponse\n allows passing two additional arguments \u2014 a\nstatus code, and an array of headers \u2014 to allow you to further seed the initial state of the\nresponse:\n\n\n$response = new JsonResponse($data, 200, [ 'Content-Type' => ['application/hal+json']]);\n\n\n\nFinally, \nJsonResponse\n allows a fourth optional argument, the flags to provide to \njson_encode()\n.\nBy default, these are set to \nJSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT\n (integer\n15), providing \nRFC 4627\n compliant JSON capable of embedding in\nHTML. If you want to specify a different set of flags, use the fourth constructor argument:\n\n\n$response = new JsonResponse(\n    $data,\n    200,\n    [],\n    JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT\n);\n\n\n\nEmpty Responses\n\n\nMany API actions allow returning empty responses:\n\n\n\n\n201 Created\n responses are often empty, and only include a \nLink\n or \nLocation\n header pointing\n  to the newly created resource.\n\n\n202 Accepted\n responses are typically empty, indicating that the new entity has been received,\n  but not yet processed.\n\n\n204 No Content\n responses are, by definition, empty, and often used as a success response when\n  deleting an entity.\n\n\n\n\nZend\\Diactoros\\Response\\EmptyResponse\n is a \nZend\\Diactoros\\Response\n extension that, by default,\nreturns an empty response with a 204 status. Its constructor allows passing the status and headers\nonly:\n\n\nclass EmptyResponse extends Response\n{\n    public function __construct($status = 204, array $headers = []);\n}\n\n\n\nAn empty, read-only body is injected at instantiation, ensuring no write operations are possible on\nthe response. Usage is typically one of the following forms:\n\n\n// Basic 204 response:\n$response = new EmptyResponse();\n\n// 201 response with location header:\n$response = new EmptyResponse(201, [\n    'Location' => [ $url ],\n]);\n\n// Alternately, set the header after instantiation:\n$response = ( new EmptyResponse(201) )->withHeader('Location', $url);\n\n\n\nRedirects\n\n\nZend\\Diactoros\\Response\\RedirectResponse\n is a \nZend\\Diactoros\\Response\n extension for producing\nredirect responses. The only required argument is a URI, which may be provided as either a string or\n\nPsr\\Http\\Message\\UriInterface\n instance. By default, the status 302 is used, and no other headers\nare produced; you may alter these via the additional optional arguments:\n\n\nclass RedirectResponse extends Response\n{\n    public function __construct($uri, $status = 302, array $headers = []);\n}\n\n\n\nTypical usage is:\n\n\n// 302 redirect:\n$response = new RedirectResponse('/user/login');\n\n// 301 redirect:\n$response = new RedirectResponse('/user/login', 301);\n\n// using a URI instance (e.g., by altering the request URI instance)\n$uri = $request->getUri();\n$response = new RedirectResponse($uri->withPath('/login'));\n\n\n\nCreating custom responses\n\n\nPHP allows constructor overloading. What this means is that constructors of extending classes can\ndefine completely different argument sets without conflicting with the parent implementation.\nConsidering that most custom response types do not need to change internal functionality, but\ninstead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to\ncreate your custom types.\n\n\nThe general pattern will be something like this:\n\n\nclass MyCustomResponse extends Response\n{\n    public function __construct($data, $status = 200, array $headers = [])\n    {\n        // - Do something with $data, and create a Stream for the body (if necessary).\n        // - Maybe set some default headers.\n\n        parent::__construct($body, $status, $headers);\n    }\n}\n\n\n\nNote the call to \nparent::__construct()\n. This is particularly relevant, as the implementation at\nthe time of writing has all class properties marked as private, making them inaccessible to\nextensions; this is done to protect encapsulation and ensure consistency of operations between\ninstances.\n\n\nIf you don't want to go the extension route (perhaps you don't want another \nResponseInterface\n\nimplementation within your object graph) you can instead create a factory. As an example:\n\n\n$plainTextResponse = function ($text, $status = 200, array $headers = []) {\n    $response = new Response('php://temp', $status, $headers);\n    $response->getBody()->write($text);\n    if (! $response->hasHeader('Content-Type')) {\n        $response = $response->withHeader('Content-Type', 'text/plain');\n    }\n    return $response;\n};\n\n$response = $plainTextResponse('Hello, world!');\n\n\n\nWe recommend following the semantic of providing the status and headers as the final two arguments\nfor any factory or custom response extensions.",
            "title": "Custom Responses"
        },
        {
            "location": "/v2/custom-responses/#custom-responses",
            "text": "When developing server-side applications, the message type you're most likely to create manually is\nthe response. In such cases, the standard signature can be an obstacle to usability. Let's review:  class Response implements ResponseInterface\n{\n    public function __construct($body = 'php://temp', $status = 200, array $headers = []);\n}  Some standard use cases, however, make this un-wieldy:   Returning a response containing HTML; in this case, you likely want to provide the HTML to the\n  constructor, not a stream with the HTML injected.  Returning a response containing JSON; in this case, you likely want to provide the data to\n  serialize to JSON, not a stream containing serialized JSON.  Returning a response with no content; in this case, you don't want to bother with the body at all.  Returning a redirect response; in this case, you likely just want to specify the target for the\n   Location  header, and optionally the status code.   Starting with version 1.1, Diactoros offers several custom response types for simplifying these\ncommon tasks.",
            "title": "Custom Responses"
        },
        {
            "location": "/v2/custom-responses/#text-responses",
            "text": "Zend\\Diactoros\\Response\\TextResponse  creates a plain text response. It sets the Content-Type  header to  text/plain  by default:  $response = new TextResponse('Hello world!');  The constructor accepts two additional arguments: a status code and an array of headers.  $response = new TextResponse($text, 200, ['Content-Type' => ['text/csv']]);",
            "title": "Text Responses"
        },
        {
            "location": "/v2/custom-responses/#html-responses",
            "text": "Zend\\Diactoros\\Response\\HtmlResponse  allows specifying HTML as a payload, and sets the Content-Type  header to  text/html  by default:  $response = new HtmlResponse($htmlContent);  The constructor allows passing two additional arguments: a status code, and an array of headers.\nThese allow you to further seed the initial state of the response, as well as to override the Content-Type  header if desired:  $response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' => ['application/xhtml+xml']]);  Headers must be in the same format as you would provide to the Response constructor .",
            "title": "HTML Responses"
        },
        {
            "location": "/v2/custom-responses/#xml-responses",
            "text": "Zend\\Diactoros\\Response\\XmlResponse  allows specifying XML as a payload, and sets the Content-Type  header to  application/xml  by default:  $response = new XmlResponse($xml);  The constructor allows passing two additional arguments: a status code, and an array of headers.\nThese allow you to further seed the initial state of the response, as well as to override the Content-Type  header if desired:  $response = new XmlResponse($xml, 200, [ 'Content-Type' => ['application/hal+xml']]);  Headers must be in the same format as you would provide to the Response constructor .",
            "title": "XML Responses"
        },
        {
            "location": "/v2/custom-responses/#json-responses",
            "text": "Zend\\Diactoros\\Response\\JsonResponse  accepts a data structure to convert to JSON, and sets\nthe  Content-Type  header to  application/json :  $response = new JsonResponse($data);  If providing an object, we recommend implementing  JsonSerializable \nto ensure your object is correctly serialized.  Just like the  HtmlResponse , the  JsonResponse  allows passing two additional arguments \u2014 a\nstatus code, and an array of headers \u2014 to allow you to further seed the initial state of the\nresponse:  $response = new JsonResponse($data, 200, [ 'Content-Type' => ['application/hal+json']]);  Finally,  JsonResponse  allows a fourth optional argument, the flags to provide to  json_encode() .\nBy default, these are set to  JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT  (integer\n15), providing  RFC 4627  compliant JSON capable of embedding in\nHTML. If you want to specify a different set of flags, use the fourth constructor argument:  $response = new JsonResponse(\n    $data,\n    200,\n    [],\n    JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT\n);",
            "title": "JSON Responses"
        },
        {
            "location": "/v2/custom-responses/#empty-responses",
            "text": "Many API actions allow returning empty responses:   201 Created  responses are often empty, and only include a  Link  or  Location  header pointing\n  to the newly created resource.  202 Accepted  responses are typically empty, indicating that the new entity has been received,\n  but not yet processed.  204 No Content  responses are, by definition, empty, and often used as a success response when\n  deleting an entity.   Zend\\Diactoros\\Response\\EmptyResponse  is a  Zend\\Diactoros\\Response  extension that, by default,\nreturns an empty response with a 204 status. Its constructor allows passing the status and headers\nonly:  class EmptyResponse extends Response\n{\n    public function __construct($status = 204, array $headers = []);\n}  An empty, read-only body is injected at instantiation, ensuring no write operations are possible on\nthe response. Usage is typically one of the following forms:  // Basic 204 response:\n$response = new EmptyResponse();\n\n// 201 response with location header:\n$response = new EmptyResponse(201, [\n    'Location' => [ $url ],\n]);\n\n// Alternately, set the header after instantiation:\n$response = ( new EmptyResponse(201) )->withHeader('Location', $url);",
            "title": "Empty Responses"
        },
        {
            "location": "/v2/custom-responses/#redirects",
            "text": "Zend\\Diactoros\\Response\\RedirectResponse  is a  Zend\\Diactoros\\Response  extension for producing\nredirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface  instance. By default, the status 302 is used, and no other headers\nare produced; you may alter these via the additional optional arguments:  class RedirectResponse extends Response\n{\n    public function __construct($uri, $status = 302, array $headers = []);\n}  Typical usage is:  // 302 redirect:\n$response = new RedirectResponse('/user/login');\n\n// 301 redirect:\n$response = new RedirectResponse('/user/login', 301);\n\n// using a URI instance (e.g., by altering the request URI instance)\n$uri = $request->getUri();\n$response = new RedirectResponse($uri->withPath('/login'));",
            "title": "Redirects"
        },
        {
            "location": "/v2/custom-responses/#creating-custom-responses",
            "text": "PHP allows constructor overloading. What this means is that constructors of extending classes can\ndefine completely different argument sets without conflicting with the parent implementation.\nConsidering that most custom response types do not need to change internal functionality, but\ninstead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to\ncreate your custom types.  The general pattern will be something like this:  class MyCustomResponse extends Response\n{\n    public function __construct($data, $status = 200, array $headers = [])\n    {\n        // - Do something with $data, and create a Stream for the body (if necessary).\n        // - Maybe set some default headers.\n\n        parent::__construct($body, $status, $headers);\n    }\n}  Note the call to  parent::__construct() . This is particularly relevant, as the implementation at\nthe time of writing has all class properties marked as private, making them inaccessible to\nextensions; this is done to protect encapsulation and ensure consistency of operations between\ninstances.  If you don't want to go the extension route (perhaps you don't want another  ResponseInterface \nimplementation within your object graph) you can instead create a factory. As an example:  $plainTextResponse = function ($text, $status = 200, array $headers = []) {\n    $response = new Response('php://temp', $status, $headers);\n    $response->getBody()->write($text);\n    if (! $response->hasHeader('Content-Type')) {\n        $response = $response->withHeader('Content-Type', 'text/plain');\n    }\n    return $response;\n};\n\n$response = $plainTextResponse('Hello, world!');  We recommend following the semantic of providing the status and headers as the final two arguments\nfor any factory or custom response extensions.",
            "title": "Creating custom responses"
        },
        {
            "location": "/v2/serialization/",
            "text": "Serialization\n\n\nString\n\n\nAt times, it's useful to either create a string representation of a message (serialization), or to\ncast a string or stream message to an object (deserialization). This package provides features for\nthis in \nZend\\Diactoros\\Request\\Serializer\n and \nZend\\Diactoros\\Response\\Serializer\n; each provides\nthe following static methods:\n\n\n\n\nfromString($message)\n will create either a \nRequest\n or \nResponse\n instance (based on the\n  serializer used) from the string message.\n\n\nfromStream(Psr\\Http\\Message\\StreamInterface $stream)\n will create either a \nRequest\n or\n  \nResponse\n instance (based on the serializer used) from the provided stream.\n\n\ntoString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)\n will\n  create either a string from the provided message.\n\n\n\n\nThe deserialization methods (\nfrom*()\n) will raise exceptions if errors occur while parsing the\nmessage. The serialization methods (\ntoString()\n) will raise exceptions if required data for\nserialization is not present in the message instance.\n\n\nArray\n\n\nThis package also provides features for array serialization using\n\nZend\\Diactoros\\Request\\ArraySerializer\n and \nZend\\Diactoros\\Response\\ArraySerializer\n; each provides\nthe following static methods:\n\n\n\n\nfromArray(array $message)\n will create either a \nRequest\n or \nResponse\n instance (based on the\n  serializer used) from the array message.\n\n\ntoArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)\n will\n  create an array from the provided message.\n\n\n\n\nThe deserialization methods (\nfromArray()\n) will raise exceptions if errors occur while parsing the\nmessage.\n\n\nExample usage\n\n\nArray serialization can be usesful for log messages:\n\n\nclass LoggerMiddleware\n{\n    /**\n     * @var \\Psr\\Log\\LoggerInterface\n     */\n    protected $logger;\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $response = $next($request, $response);\n\n        $this->logger->debug('Request/Response', [\n            'request' => \\Zend\\Diactoros\\Request\\ArraySerializer::toArray($request),\n            'response' => \\Zend\\Diactoros\\Response\\ArraySerializer::toArray($response),\n        ]);\n\n        return $response;\n    }\n}",
            "title": "Serialization"
        },
        {
            "location": "/v2/serialization/#serialization",
            "text": "",
            "title": "Serialization"
        },
        {
            "location": "/v2/serialization/#string",
            "text": "At times, it's useful to either create a string representation of a message (serialization), or to\ncast a string or stream message to an object (deserialization). This package provides features for\nthis in  Zend\\Diactoros\\Request\\Serializer  and  Zend\\Diactoros\\Response\\Serializer ; each provides\nthe following static methods:   fromString($message)  will create either a  Request  or  Response  instance (based on the\n  serializer used) from the string message.  fromStream(Psr\\Http\\Message\\StreamInterface $stream)  will create either a  Request  or\n   Response  instance (based on the serializer used) from the provided stream.  toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)  will\n  create either a string from the provided message.   The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the\nmessage. The serialization methods ( toString() ) will raise exceptions if required data for\nserialization is not present in the message instance.",
            "title": "String"
        },
        {
            "location": "/v2/serialization/#array",
            "text": "This package also provides features for array serialization using Zend\\Diactoros\\Request\\ArraySerializer  and  Zend\\Diactoros\\Response\\ArraySerializer ; each provides\nthe following static methods:   fromArray(array $message)  will create either a  Request  or  Response  instance (based on the\n  serializer used) from the array message.  toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)  will\n  create an array from the provided message.   The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the\nmessage.",
            "title": "Array"
        },
        {
            "location": "/v2/serialization/#example-usage",
            "text": "Array serialization can be usesful for log messages:  class LoggerMiddleware\n{\n    /**\n     * @var \\Psr\\Log\\LoggerInterface\n     */\n    protected $logger;\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $response = $next($request, $response);\n\n        $this->logger->debug('Request/Response', [\n            'request' => \\Zend\\Diactoros\\Request\\ArraySerializer::toArray($request),\n            'response' => \\Zend\\Diactoros\\Response\\ArraySerializer::toArray($response),\n        ]);\n\n        return $response;\n    }\n}",
            "title": "Example usage"
        },
        {
            "location": "/v2/api/",
            "text": "API\n\n\nRequest Message\n\n\nZend\\Diactoros\\Request\n implements \nPsr\\Http\\Message\\RequestInterface\n,\nand is intended for client-side requests. It includes the following methods:\n\n\nclass Request\n{\n    public function __construct(\n        $uri = null,\n        $method = null,\n        $body = 'php://memory',\n        array $headers = []\n    );\n\n    // See psr/http-message's RequestInterface for other methods\n}\n\n\n\nRequests are immutable. Any methods that would change state \u2014 those prefixed with \nwith\n and\n\nwithout\n \u2014 all return a new instance with the changes requested.\n\n\nServerRequest Message\n\n\nFor server-side applications, \nZend\\Diactoros\\ServerRequest\n implements\n\nPsr\\Http\\Message\\ServerRequestInterface\n,\nwhich provides access to the elements of an HTTP request, as well as uniform access to the various\nelements of incoming data. The methods included are:\n\n\nclass ServerRequest\n{\n    public function __construct(\n        array $serverParams = [],\n        array $fileParams = [],\n        $uri = null,\n        $method = null,\n        $body = 'php://input',\n        array $headers = []\n    );\n\n    // See psr/http-message's ServerRequestInterface for other methods.\n}\n\n\n\nThe \nServerRequest\n is immutable. Any methods that would change state \u2014 those prefixed with \nwith\n\nand \nwithout\n \u2014 all return a new instance with the changes requested. Server parameters are\nconsidered completely immutable, however, as they cannot be recalculated, and, rather, is a source\nfor other values.\n\n\nResponse Message\n\n\nZend\\Diactoros\\Response\n provides an implementation of\n\nPsr\\Http\\Message\\ResponseInterface\n,\nan object to be used to aggregate response information for both HTTP clients and server-side\napplications, including headers and message body content. It includes the following:\n\n\nclass Response\n{\n    public function __construct(\n        $body = 'php://memory',\n        $statusCode = 200,\n        array $headers = []\n    );\n\n    // See psr/http-message's ResponseInterface for other methods\n}\n\n\n\nLike the \nRequest\n and \nServerRequest\n, responses are immutable. Any methods that would change state\n\u2014 those prefixed with \nwith\n and \nwithout\n \u2014 all return a new instance with the changes requested.\n\n\nHtmlResponse and JsonResponse\n\n\nThe most common use case in server-side applications for generating responses is to provide a string\nto use for the response, typically HTML or data to serialize as JSON.  \nZend\\Diactoros\\Response\\HtmlResponse\n and \nZend\\Diactoros\\Response\\JsonResponse\n exist to facilitate these use cases:\n\n\n$htmlResponse = new HtmlResponse($html);\n\n$jsonResponse = new JsonResponse($data);\n\n\n\nIn the first example, you will receive a response with a stream containing the HTML; additionally,\nthe \nContent-Type\n header will be set to \ntext/html\n. In the second case, the stream will contain a\nstream containing the JSON-serialized \n$data\n, and have a \nContent-Type\n header set to\n\napplication/json\n.\n\n\nBoth objects allow passing the HTTP status, as well as any headers you want to specify,\nincluding the \nContent-Type\n header:\n\n\n$htmlResponse = new HtmlResponse($html, 404, [\n    'Content-Type' => [ 'application/xhtml+xml' ],\n]);\n\n$jsonResponse = new JsonResponse($data, 422, [\n    'Content-Type' => [ 'application/problem+json' ],\n]);\n\n\n\nServerRequestFactory\n\n\nThis static class can be used to marshal a \nServerRequest\n instance from the PHP environment. The\nprimary entry point is \nZend\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array\n$query, array $body, array $cookies, array $files)\n. This method will create a new \nServerRequest\n\ninstance with the data provided. Examples of usage are:\n\n\n// Returns new ServerRequest instance, using values from superglobals:\n$request = ServerRequestFactory::fromGlobals();\n\n// or\n\n// Returns new ServerRequest instance, using values provided (in this\n// case, equivalent to the previous!)\n$request = RequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);\n\n\n\nServerRequestFactory helper functions\n\n\nIn order to create the various artifacts required by a \nServerRequest\n instance,\nDiactoros also provides a number of functions under the \nZend\\Diactoros\n\nnamespace for introspecting the SAPI \n$_SERVER\n parameters, headers, \n$_FILES\n,\nand even the \nCookie\n header. These include:\n\n\n\n\nZend\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array\n\n  (its main purpose is to aggregate the \nAuthorization\n header in the SAPI params\n  when under Apache)\n\n\nZend\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string\n\n\nZend\\Diactoros\\marshalMethodFromSapi(array $server) : string\n\n\nZend\\Diactoros\\marshalUriFromSapi(array $server, array $headers) : Uri\n\n\nZend\\Diactoros\\marshalHeadersFromSapi(array $server) : array\n\n\nZend\\Diactoros\\parseCookieHeader(string $header) : array\n\n\nZend\\Diactoros\\createUploadedFile(array $spec) : UploadedFile\n (creates the\n  instance from a normal \n$_FILES\n entry)\n\n\nZend\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[]\n\n  (traverses a potentially nested array of uploaded file instances and/or\n  \n$_FILES\n entries, including those aggregated under mod_php, php-fpm, and\n  php-cgi in order to create a flat array of \nUploadedFileInterface\n instances\n  to use in a request)\n\n\n\n\nURI\n\n\nZend\\Diactoros\\Uri\n is an implementation of\n\nPsr\\Http\\Message\\UriInterface\n,\nand models and validates URIs. It implements \n__toString()\n, allowing it to be represented as a\nstring and \necho()\n'd directly. The following methods are pertinent:\n\n\nclass Uri\n{\n    public function __construct($uri = '');\n\n    // See psr/http-message's UriInterface for other methods.\n}\n\n\n\nLike the various message objects, URIs are immutable. Any methods that would\nchange state \u2014 those\nprefixed with \nwith\n and \nwithout\n \u2014 all return a new instance with the changes requested.\n\n\nStream\n\n\nZend\\Diactoros\\Stream\n is an implementation of\n\nPsr\\Http\\Message\\StreamInterface\n,\nand provides a number of facilities around manipulating the composed PHP stream resource. The\nconstructor accepts a stream, which may be either:\n\n\n\n\na stream identifier; e.g., \nphp://input\n, a filename, etc.\n\n\na PHP stream resource\n\n\n\n\nIf a stream identifier is provided, an optional second parameter may be provided, the file mode by\nwhich to \nfopen\n the stream.\n\n\nServerRequest\n objects by default use a \nphp://input\n stream set to read-only; \nResponse\n objects\nby default use a \nphp://memory\n with a mode of \nwb+\n, allowing binary read/write access.\n\n\nIn most cases, you will not interact with the Stream object directly.\n\n\nUploadedFile\n\n\nZend\\Diactoros\\UploadedFile\n is an implementation of\n\nPsr\\Http\\Message\\UploadedFileInterface\n,\nand provides abstraction around a single uploaded file, including behavior for interacting with it\nas a stream or moving it to a filesystem location.\n\n\nIn most cases, you will only use the methods defined in the \nUploadedFileInterface\n.",
            "title": "API"
        },
        {
            "location": "/v2/api/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/v2/api/#request-message",
            "text": "Zend\\Diactoros\\Request  implements  Psr\\Http\\Message\\RequestInterface ,\nand is intended for client-side requests. It includes the following methods:  class Request\n{\n    public function __construct(\n        $uri = null,\n        $method = null,\n        $body = 'php://memory',\n        array $headers = []\n    );\n\n    // See psr/http-message's RequestInterface for other methods\n}  Requests are immutable. Any methods that would change state \u2014 those prefixed with  with  and without  \u2014 all return a new instance with the changes requested.",
            "title": "Request Message"
        },
        {
            "location": "/v2/api/#serverrequest-message",
            "text": "For server-side applications,  Zend\\Diactoros\\ServerRequest  implements Psr\\Http\\Message\\ServerRequestInterface ,\nwhich provides access to the elements of an HTTP request, as well as uniform access to the various\nelements of incoming data. The methods included are:  class ServerRequest\n{\n    public function __construct(\n        array $serverParams = [],\n        array $fileParams = [],\n        $uri = null,\n        $method = null,\n        $body = 'php://input',\n        array $headers = []\n    );\n\n    // See psr/http-message's ServerRequestInterface for other methods.\n}  The  ServerRequest  is immutable. Any methods that would change state \u2014 those prefixed with  with \nand  without  \u2014 all return a new instance with the changes requested. Server parameters are\nconsidered completely immutable, however, as they cannot be recalculated, and, rather, is a source\nfor other values.",
            "title": "ServerRequest Message"
        },
        {
            "location": "/v2/api/#response-message",
            "text": "Zend\\Diactoros\\Response  provides an implementation of Psr\\Http\\Message\\ResponseInterface ,\nan object to be used to aggregate response information for both HTTP clients and server-side\napplications, including headers and message body content. It includes the following:  class Response\n{\n    public function __construct(\n        $body = 'php://memory',\n        $statusCode = 200,\n        array $headers = []\n    );\n\n    // See psr/http-message's ResponseInterface for other methods\n}  Like the  Request  and  ServerRequest , responses are immutable. Any methods that would change state\n\u2014 those prefixed with  with  and  without  \u2014 all return a new instance with the changes requested.",
            "title": "Response Message"
        },
        {
            "location": "/v2/api/#htmlresponse-and-jsonresponse",
            "text": "The most common use case in server-side applications for generating responses is to provide a string\nto use for the response, typically HTML or data to serialize as JSON.   Zend\\Diactoros\\Response\\HtmlResponse  and  Zend\\Diactoros\\Response\\JsonResponse  exist to facilitate these use cases:  $htmlResponse = new HtmlResponse($html);\n\n$jsonResponse = new JsonResponse($data);  In the first example, you will receive a response with a stream containing the HTML; additionally,\nthe  Content-Type  header will be set to  text/html . In the second case, the stream will contain a\nstream containing the JSON-serialized  $data , and have a  Content-Type  header set to application/json .  Both objects allow passing the HTTP status, as well as any headers you want to specify,\nincluding the  Content-Type  header:  $htmlResponse = new HtmlResponse($html, 404, [\n    'Content-Type' => [ 'application/xhtml+xml' ],\n]);\n\n$jsonResponse = new JsonResponse($data, 422, [\n    'Content-Type' => [ 'application/problem+json' ],\n]);",
            "title": "HtmlResponse and JsonResponse"
        },
        {
            "location": "/v2/api/#serverrequestfactory",
            "text": "This static class can be used to marshal a  ServerRequest  instance from the PHP environment. The\nprimary entry point is  Zend\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array\n$query, array $body, array $cookies, array $files) . This method will create a new  ServerRequest \ninstance with the data provided. Examples of usage are:  // Returns new ServerRequest instance, using values from superglobals:\n$request = ServerRequestFactory::fromGlobals();\n\n// or\n\n// Returns new ServerRequest instance, using values provided (in this\n// case, equivalent to the previous!)\n$request = RequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);",
            "title": "ServerRequestFactory"
        },
        {
            "location": "/v2/api/#serverrequestfactory-helper-functions",
            "text": "In order to create the various artifacts required by a  ServerRequest  instance,\nDiactoros also provides a number of functions under the  Zend\\Diactoros \nnamespace for introspecting the SAPI  $_SERVER  parameters, headers,  $_FILES ,\nand even the  Cookie  header. These include:   Zend\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array \n  (its main purpose is to aggregate the  Authorization  header in the SAPI params\n  when under Apache)  Zend\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string  Zend\\Diactoros\\marshalMethodFromSapi(array $server) : string  Zend\\Diactoros\\marshalUriFromSapi(array $server, array $headers) : Uri  Zend\\Diactoros\\marshalHeadersFromSapi(array $server) : array  Zend\\Diactoros\\parseCookieHeader(string $header) : array  Zend\\Diactoros\\createUploadedFile(array $spec) : UploadedFile  (creates the\n  instance from a normal  $_FILES  entry)  Zend\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[] \n  (traverses a potentially nested array of uploaded file instances and/or\n   $_FILES  entries, including those aggregated under mod_php, php-fpm, and\n  php-cgi in order to create a flat array of  UploadedFileInterface  instances\n  to use in a request)",
            "title": "ServerRequestFactory helper functions"
        },
        {
            "location": "/v2/api/#uri",
            "text": "Zend\\Diactoros\\Uri  is an implementation of Psr\\Http\\Message\\UriInterface ,\nand models and validates URIs. It implements  __toString() , allowing it to be represented as a\nstring and  echo() 'd directly. The following methods are pertinent:  class Uri\n{\n    public function __construct($uri = '');\n\n    // See psr/http-message's UriInterface for other methods.\n}  Like the various message objects, URIs are immutable. Any methods that would\nchange state \u2014 those\nprefixed with  with  and  without  \u2014 all return a new instance with the changes requested.",
            "title": "URI"
        },
        {
            "location": "/v2/api/#stream",
            "text": "Zend\\Diactoros\\Stream  is an implementation of Psr\\Http\\Message\\StreamInterface ,\nand provides a number of facilities around manipulating the composed PHP stream resource. The\nconstructor accepts a stream, which may be either:   a stream identifier; e.g.,  php://input , a filename, etc.  a PHP stream resource   If a stream identifier is provided, an optional second parameter may be provided, the file mode by\nwhich to  fopen  the stream.  ServerRequest  objects by default use a  php://input  stream set to read-only;  Response  objects\nby default use a  php://memory  with a mode of  wb+ , allowing binary read/write access.  In most cases, you will not interact with the Stream object directly.",
            "title": "Stream"
        },
        {
            "location": "/v2/api/#uploadedfile",
            "text": "Zend\\Diactoros\\UploadedFile  is an implementation of Psr\\Http\\Message\\UploadedFileInterface ,\nand provides abstraction around a single uploaded file, including behavior for interacting with it\nas a stream or moving it to a filesystem location.  In most cases, you will only use the methods defined in the  UploadedFileInterface .",
            "title": "UploadedFile"
        },
        {
            "location": "/v2/migration/",
            "text": "Migration to version 2\n\n\nIf you are only using the PSR-7 implementations (e.g., \nRequest\n, \nResponse\n,\n\nServerRequest\n, etc.), migrating to v2 can be done by updating your\nzendframework/zend-diactoros constraint in your \ncomposer.json\n. You have two\noptions for doing so:\n\n\n\n\nAdopt the v2 release specifically:\n\n\n\n\n$ composer require \"zendframework/zend-diactoros:^2.0\"\n\n\n\n\n\n\n\nUpdate your constraint to allow either version:\n\n\n\n\n\n\nEdit the constraint in your \ncomposer.json\n to read:\n\n\n\"zendframework/zend-diactoros\": \"^1.8.6 || ^2.0\"\n\n\n\n\n\n\n\nUpdate your dependencies:\n\n\n$ composer update\n\n\n\n\n\n\n\nThe first approach may fail if libraries you depend on specifically require a\nversion 1 release. The second approach may leave you on a version 1 release in\nsituations where other libraries you depend on require version 1.\n\n\nIn all cases, if you are only using the PSR-7 implementations and/or the\n\nServerRequestFactory::fromGlobals()\n functionality, upgrading to version 2 will\npose no backwards compatibility issues.\n\n\nChanged\n\n\n\n\n\n\nZend\\Diactoros\\RequestTrait\n now raises an \nInvalidArgumentException\n in\n  \nwithMethod()\n for invalid HTTP method values.\n\n\n\n\n\n\nZend\\Diactoros\\Serializer\\Request::toString()\n no longer raises an\n  \nUnexpectedValueException\n due to an unexpected HTTP method; this is due to the\n  fact that the HTTP method value can no longer be set to an invalid value.\n\n\n\n\n\n\nRemoved\n\n\nSeveral features were removed for version 2. These include removal of the\n\nEmitter\n functionality, the \nServer\n implementation, and a number of methods on\nthe \nServerRequestFactory\n.\n\n\nEmitters\n\n\nZend\\Diactoros\\Response\\EmitterInterface\n and all emitter implementations were\nremoved from zend-diactoros. They are now available in the\n\nzendframework/zend-httphandlerrunner package\n.\nIn most cases, these can be replaced by changing the namespace of imported\nclasses from \nZend\\Diactoros\\Response\n to \nZend\\HttpHandlerRunner\\Emitter\n.\n\n\nServer\n\n\nThe \nZend\\Diactoros\\Server\n class has been removed. We recommend using the\n\nRequestHandlerRunner\n class from \nzendframework/zend-httphandlerrunner\n\nto provide these capabilities instead. Usage is similar, but the\n\nRequestHandlerRunner\n provides better error handling, and integration with\nemitters.\n\n\nServerRequestFactory methods\n\n\nA number of public static methods have been removed from\n\nServerRequestFactory\n. The following table details the methods removed, and\nreplacements you may use if you still require the functionality.\n\n\n\n\n\n\n\n\nMethod Removed\n\n\nReplacement functionality\n\n\n\n\n\n\n\n\n\n\nnormalizeServer()\n\n\nZend\\Diactoros\\normalizeServer()\n\n\n\n\n\n\nmarshalHeaders()\n\n\nZend\\Diactoros\\marshalHeadersFromSapi()\n\n\n\n\n\n\nmarshalUriFromServer()\n\n\nZend\\Diactoros\\marshalUriFromSapi()\n\n\n\n\n\n\nmarshalRequestUri()\n\n\nUri::getPath()\n from the \nUri\n instance returned by \nmarshalUriFromSapi()\n\n\n\n\n\n\nmarshalHostAndPortFromHeaders()\n\n\nUri::getHost()\n and \nUri::getPort()\n from the \nUri\n instances returned by \nmarshalUriFromSapi()\n\n\n\n\n\n\nstripQueryString()\n\n\nexplode(\"?\", $path, 2)[0]\n\n\n\n\n\n\nnormalizeFiles()\n\n\nZend\\Diactoros\\normalizeUploadedFiles()",
            "title": "Migration"
        },
        {
            "location": "/v2/migration/#migration-to-version-2",
            "text": "If you are only using the PSR-7 implementations (e.g.,  Request ,  Response , ServerRequest , etc.), migrating to v2 can be done by updating your\nzendframework/zend-diactoros constraint in your  composer.json . You have two\noptions for doing so:   Adopt the v2 release specifically:   $ composer require \"zendframework/zend-diactoros:^2.0\"    Update your constraint to allow either version:    Edit the constraint in your  composer.json  to read:  \"zendframework/zend-diactoros\": \"^1.8.6 || ^2.0\"    Update your dependencies:  $ composer update    The first approach may fail if libraries you depend on specifically require a\nversion 1 release. The second approach may leave you on a version 1 release in\nsituations where other libraries you depend on require version 1.  In all cases, if you are only using the PSR-7 implementations and/or the ServerRequestFactory::fromGlobals()  functionality, upgrading to version 2 will\npose no backwards compatibility issues.",
            "title": "Migration to version 2"
        },
        {
            "location": "/v2/migration/#changed",
            "text": "Zend\\Diactoros\\RequestTrait  now raises an  InvalidArgumentException  in\n   withMethod()  for invalid HTTP method values.    Zend\\Diactoros\\Serializer\\Request::toString()  no longer raises an\n   UnexpectedValueException  due to an unexpected HTTP method; this is due to the\n  fact that the HTTP method value can no longer be set to an invalid value.",
            "title": "Changed"
        },
        {
            "location": "/v2/migration/#removed",
            "text": "Several features were removed for version 2. These include removal of the Emitter  functionality, the  Server  implementation, and a number of methods on\nthe  ServerRequestFactory .",
            "title": "Removed"
        },
        {
            "location": "/v2/migration/#emitters",
            "text": "Zend\\Diactoros\\Response\\EmitterInterface  and all emitter implementations were\nremoved from zend-diactoros. They are now available in the zendframework/zend-httphandlerrunner package .\nIn most cases, these can be replaced by changing the namespace of imported\nclasses from  Zend\\Diactoros\\Response  to  Zend\\HttpHandlerRunner\\Emitter .",
            "title": "Emitters"
        },
        {
            "location": "/v2/migration/#server",
            "text": "The  Zend\\Diactoros\\Server  class has been removed. We recommend using the RequestHandlerRunner  class from  zendframework/zend-httphandlerrunner \nto provide these capabilities instead. Usage is similar, but the RequestHandlerRunner  provides better error handling, and integration with\nemitters.",
            "title": "Server"
        },
        {
            "location": "/v2/migration/#serverrequestfactory-methods",
            "text": "A number of public static methods have been removed from ServerRequestFactory . The following table details the methods removed, and\nreplacements you may use if you still require the functionality.     Method Removed  Replacement functionality      normalizeServer()  Zend\\Diactoros\\normalizeServer()    marshalHeaders()  Zend\\Diactoros\\marshalHeadersFromSapi()    marshalUriFromServer()  Zend\\Diactoros\\marshalUriFromSapi()    marshalRequestUri()  Uri::getPath()  from the  Uri  instance returned by  marshalUriFromSapi()    marshalHostAndPortFromHeaders()  Uri::getHost()  and  Uri::getPort()  from the  Uri  instances returned by  marshalUriFromSapi()    stripQueryString()  explode(\"?\", $path, 2)[0]    normalizeFiles()  Zend\\Diactoros\\normalizeUploadedFiles()",
            "title": "ServerRequestFactory methods"
        },
        {
            "location": "/v1/overview/",
            "text": "zend-diactoros: HTTP Messages\n\n\nzend-diactoros\n is a PHP package containing implementations of the \naccepted PSR-7 HTTP message\ninterfaces\n, as\nwell as a \"server\" implementation similar to \nnode's http.Server\n.\n\n\nThis package exists:\n\n\n\n\nto provide an implementation of \nPSR-7 HTTP message interfaces\n\n\nwith relation to server-side applications.\n\n\nto provide a common methodology for marshaling a request from the server environment.",
            "title": "Overview"
        },
        {
            "location": "/v1/overview/#zend-diactoros-http-messages",
            "text": "zend-diactoros  is a PHP package containing implementations of the  accepted PSR-7 HTTP message\ninterfaces , as\nwell as a \"server\" implementation similar to  node's http.Server .  This package exists:   to provide an implementation of  PSR-7 HTTP message interfaces  with relation to server-side applications.  to provide a common methodology for marshaling a request from the server environment.",
            "title": "zend-diactoros: HTTP Messages"
        },
        {
            "location": "/v1/install/",
            "text": "Installation and Requirements\n\n\nInstall this library using composer:\n\n\n$ composer require \"zendframework/zend-diactoros:^1.8.6\"\n\n\n\nzend-diactoros\n has the following dependencies (which are managed by Composer):\n\n\n\n\npsr/http-message\n, which defines interfaces for HTTP messages, including requests and responses.\n  \nzend-diactoros\n provides implementations of each of these.",
            "title": "Installation"
        },
        {
            "location": "/v1/install/#installation-and-requirements",
            "text": "Install this library using composer:  $ composer require \"zendframework/zend-diactoros:^1.8.6\"  zend-diactoros  has the following dependencies (which are managed by Composer):   psr/http-message , which defines interfaces for HTTP messages, including requests and responses.\n   zend-diactoros  provides implementations of each of these.",
            "title": "Installation and Requirements"
        },
        {
            "location": "/v1/usage/",
            "text": "Usage\n\n\nUsage will differ based on whether you are writing an HTTP client, or a server-side application.\n\n\nFor HTTP client purposes, you will create and populate a \nRequest\n instance, and the client should\nreturn a \nResponse\n instance.\n\n\nFor server-side applications, you will create a \nServerRequest\n instance, and populate and return a\n\nResponse\n instance.\n\n\nHTTP Clients\n\n\nA client will \nsend\n a request, and \nreturn\n a response. As a developer, you will \ncreate\n and\n\npopulate\n the request, and then \nintrospect\n the response.  Both requests and responses are\nimmutable; if you make changes \u2014 e.g., by calling setter methods \u2014 you must capture the return\nvalue, as it is a new instance.\n\n\n// Create a request\n$request = (new Zend\\Diactoros\\Request())\n    ->withUri(new Zend\\Diactoros\\Uri('http://example.com'))\n    ->withMethod('PATCH')\n    ->withAddedHeader('Authorization', 'Bearer ' . $token)\n    ->withAddedHeader('Content-Type', 'application/json');\n\n// OR:\n$request = new Zend\\Diactoros\\Request(\n    'http://example.com',\n    'PATCH',\n    'php://memory',\n    [\n        'Authorization' => 'Bearer ' . $token,\n        'Content-Type'  => 'application/json',\n    ]\n);\n\n// If you want to set a non-origin-form request target, set the\n// request-target explicitly:\n$request = $request->withRequestTarget((string) $uri);       // absolute-form\n$request = $request->withRequestTarget($uri->getAuthority()); // authority-form\n$request = $request->withRequestTarget('*');                 // asterisk-form\n\n// Once you have the instance:\n$request->getBody()->write(json_encode($data));\n$response = $client->send($request);\n\nprintf(\"Response status: %d (%s)\\n\", $response->getStatusCode(), $response->getReasonPhrase());\nprintf(\"Headers:\\n\");\nforeach ($response->getHeaders() as $header => $values) {\n    printf(\"    %s: %s\\n\", $header, implode(', ', $values));\n}\nprintf(\"Message:\\n%s\\n\", $response->getBody());\n\n\n\n(Note: \nzend-diactoros\n does NOT ship with a client implementation; the above is just an\nillustration of a possible implementation.)\n\n\nServer-Side Applications\n\n\nServer-side applications will need to marshal the incoming request based on superglobals, and will\nthen populate and send a response.\n\n\nMarshaling an incoming request\n\n\nPHP contains a plethora of information about the incoming request, and keeps that information in a\nvariety of locations. \nZend\\Diactoros\\ServerRequestFactory::fromGlobals()\n can simplify marshaling\nthat information into a request instance.\n\n\nYou can call the factory method with or without the following arguments, in the following order:\n\n\n\n\n$server\n, typically \n$_SERVER\n\n\n$query\n, typically \n$_GET\n\n\n$body\n, typically \n$_POST\n\n\n$cookies\n, typically \n$_COOKIE\n\n\n$files\n, typically \n$_FILES\n\n\n\n\nThe method will then return a \nZend\\Diactoros\\ServerRequest\n instance. If any argument is omitted,\nthe associated superglobal will be used.\n\n\n$request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);\n\n\n\nWhen no cookie array is supplied, \nfromGlobals\n will first try to parse the supplied \ncookie\n header\nbefore falling back to the \n$_COOKIE\n superglobal. This is done because PHP has some legacy handling\nfor request parameters which were then registered as global variables. Due to this, cookies with a period\nin the name were renamed with underlines. By getting the cookies directly from the cookie header, you have\naccess to the original cookies in the way you set them in your application and they are send by the user\nagent.\n\n\nManipulating the response\n\n\nUse the response object to add headers and provide content for the response.  Writing to the body\ndoes not create a state change in the response, so it can be done without capturing the return\nvalue. Manipulating headers does, however.\n\n\n$response = new Zend\\Diactoros\\Response();\n\n// Write to the response body:\n$response->getBody()->write(\"some content\\n\");\n\n// Multiple calls to write() append:\n$response->getBody()->write(\"more content\\n\"); // now \"some content\\nmore content\\n\"\n\n// Add headers\n// Note: headers do not need to be added before data is written to the body!\n$response = $response\n    ->withHeader('Content-Type', 'text/plain')\n    ->withAddedHeader('X-Show-Something', 'something');\n\n\n\n\"Serving\" an application\n\n\n\n\nDeprecated\n\n\nThe class \nZend\\Diactoros\\Server\n is deprecated as of the 1.8.0 release. We\nrecommend using the class \nZend\\HttpHandlerRunner\\RequestHandlerRunner\n via\nthe package \nzendframework/zend-httphandlerrunner\n\ninstead.\n\n\n\n\nZend\\Diactoros\\Server\n mimics a portion of the API of node's \nhttp.Server\n class. It invokes a\ncallback, passing it an \nServerRequest\n, an \nResponse\n, and optionally a callback to use for\nincomplete/unhandled requests.\n\n\nYou can create a server in one of three ways:\n\n\n// Direct instantiation, with a callback handler, request, and response\n$server = new Zend\\Diactoros\\Server(\n    function ($request, $response, $done) {\n        $response->getBody()->write(\"Hello world!\");\n    },\n    $request,\n    $response\n);\n\n// Using the createServer factory, providing it with the various superglobals:\n$server = Zend\\Diactoros\\Server::createServer(\n    function ($request, $response, $done) {\n        $response->getBody()->write(\"Hello world!\");\n    },\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);\n\n// Using the createServerFromRequest factory, and providing it a request:\n$server = Zend\\Diactoros\\Server::createServerFromRequest(\n  function ($request, $response, $done) {\n      $response->getBody()->write(\"Hello world!\");\n  },\n  $request\n);\n\n\n\nServer callbacks can expect up to three arguments, in the following order:\n\n\n\n\n$request\n - the request object\n\n\n$response\n - the response object\n\n\n$done\n - an optional callback to call when complete\n\n\n\n\nOnce you have your server instance, you must instruct it to listen:\n\n\n$server->listen();\n\n\n\nAt this time, you can optionally provide a callback to \nlisten()\n; this will be passed to the\nhandler as the third argument (\n$done\n):\n\n\n$server->listen(function ($request, $response, $error = null) {\n    if (! $error) {\n        return;\n    }\n    // do something with the error...\n});\n\n\n\nTypically, the \nlisten\n callback will be an error handler, and can expect to receive the request,\nresponse, and error as its arguments (though the error may be null).",
            "title": "Usage"
        },
        {
            "location": "/v1/usage/#usage",
            "text": "Usage will differ based on whether you are writing an HTTP client, or a server-side application.  For HTTP client purposes, you will create and populate a  Request  instance, and the client should\nreturn a  Response  instance.  For server-side applications, you will create a  ServerRequest  instance, and populate and return a Response  instance.",
            "title": "Usage"
        },
        {
            "location": "/v1/usage/#http-clients",
            "text": "A client will  send  a request, and  return  a response. As a developer, you will  create  and populate  the request, and then  introspect  the response.  Both requests and responses are\nimmutable; if you make changes \u2014 e.g., by calling setter methods \u2014 you must capture the return\nvalue, as it is a new instance.  // Create a request\n$request = (new Zend\\Diactoros\\Request())\n    ->withUri(new Zend\\Diactoros\\Uri('http://example.com'))\n    ->withMethod('PATCH')\n    ->withAddedHeader('Authorization', 'Bearer ' . $token)\n    ->withAddedHeader('Content-Type', 'application/json');\n\n// OR:\n$request = new Zend\\Diactoros\\Request(\n    'http://example.com',\n    'PATCH',\n    'php://memory',\n    [\n        'Authorization' => 'Bearer ' . $token,\n        'Content-Type'  => 'application/json',\n    ]\n);\n\n// If you want to set a non-origin-form request target, set the\n// request-target explicitly:\n$request = $request->withRequestTarget((string) $uri);       // absolute-form\n$request = $request->withRequestTarget($uri->getAuthority()); // authority-form\n$request = $request->withRequestTarget('*');                 // asterisk-form\n\n// Once you have the instance:\n$request->getBody()->write(json_encode($data));\n$response = $client->send($request);\n\nprintf(\"Response status: %d (%s)\\n\", $response->getStatusCode(), $response->getReasonPhrase());\nprintf(\"Headers:\\n\");\nforeach ($response->getHeaders() as $header => $values) {\n    printf(\"    %s: %s\\n\", $header, implode(', ', $values));\n}\nprintf(\"Message:\\n%s\\n\", $response->getBody());  (Note:  zend-diactoros  does NOT ship with a client implementation; the above is just an\nillustration of a possible implementation.)",
            "title": "HTTP Clients"
        },
        {
            "location": "/v1/usage/#server-side-applications",
            "text": "Server-side applications will need to marshal the incoming request based on superglobals, and will\nthen populate and send a response.",
            "title": "Server-Side Applications"
        },
        {
            "location": "/v1/usage/#marshaling-an-incoming-request",
            "text": "PHP contains a plethora of information about the incoming request, and keeps that information in a\nvariety of locations.  Zend\\Diactoros\\ServerRequestFactory::fromGlobals()  can simplify marshaling\nthat information into a request instance.  You can call the factory method with or without the following arguments, in the following order:   $server , typically  $_SERVER  $query , typically  $_GET  $body , typically  $_POST  $cookies , typically  $_COOKIE  $files , typically  $_FILES   The method will then return a  Zend\\Diactoros\\ServerRequest  instance. If any argument is omitted,\nthe associated superglobal will be used.  $request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);  When no cookie array is supplied,  fromGlobals  will first try to parse the supplied  cookie  header\nbefore falling back to the  $_COOKIE  superglobal. This is done because PHP has some legacy handling\nfor request parameters which were then registered as global variables. Due to this, cookies with a period\nin the name were renamed with underlines. By getting the cookies directly from the cookie header, you have\naccess to the original cookies in the way you set them in your application and they are send by the user\nagent.",
            "title": "Marshaling an incoming request"
        },
        {
            "location": "/v1/usage/#manipulating-the-response",
            "text": "Use the response object to add headers and provide content for the response.  Writing to the body\ndoes not create a state change in the response, so it can be done without capturing the return\nvalue. Manipulating headers does, however.  $response = new Zend\\Diactoros\\Response();\n\n// Write to the response body:\n$response->getBody()->write(\"some content\\n\");\n\n// Multiple calls to write() append:\n$response->getBody()->write(\"more content\\n\"); // now \"some content\\nmore content\\n\"\n\n// Add headers\n// Note: headers do not need to be added before data is written to the body!\n$response = $response\n    ->withHeader('Content-Type', 'text/plain')\n    ->withAddedHeader('X-Show-Something', 'something');",
            "title": "Manipulating the response"
        },
        {
            "location": "/v1/usage/#serving-an-application",
            "text": "",
            "title": "\"Serving\" an application"
        },
        {
            "location": "/v1/usage/#deprecated",
            "text": "The class  Zend\\Diactoros\\Server  is deprecated as of the 1.8.0 release. We\nrecommend using the class  Zend\\HttpHandlerRunner\\RequestHandlerRunner  via\nthe package  zendframework/zend-httphandlerrunner \ninstead.   Zend\\Diactoros\\Server  mimics a portion of the API of node's  http.Server  class. It invokes a\ncallback, passing it an  ServerRequest , an  Response , and optionally a callback to use for\nincomplete/unhandled requests.  You can create a server in one of three ways:  // Direct instantiation, with a callback handler, request, and response\n$server = new Zend\\Diactoros\\Server(\n    function ($request, $response, $done) {\n        $response->getBody()->write(\"Hello world!\");\n    },\n    $request,\n    $response\n);\n\n// Using the createServer factory, providing it with the various superglobals:\n$server = Zend\\Diactoros\\Server::createServer(\n    function ($request, $response, $done) {\n        $response->getBody()->write(\"Hello world!\");\n    },\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);\n\n// Using the createServerFromRequest factory, and providing it a request:\n$server = Zend\\Diactoros\\Server::createServerFromRequest(\n  function ($request, $response, $done) {\n      $response->getBody()->write(\"Hello world!\");\n  },\n  $request\n);  Server callbacks can expect up to three arguments, in the following order:   $request  - the request object  $response  - the response object  $done  - an optional callback to call when complete   Once you have your server instance, you must instruct it to listen:  $server->listen();  At this time, you can optionally provide a callback to  listen() ; this will be passed to the\nhandler as the third argument ( $done ):  $server->listen(function ($request, $response, $error = null) {\n    if (! $error) {\n        return;\n    }\n    // do something with the error...\n});  Typically, the  listen  callback will be an error handler, and can expect to receive the request,\nresponse, and error as its arguments (though the error may be null).",
            "title": "Deprecated"
        },
        {
            "location": "/v1/custom-responses/",
            "text": "Custom Responses\n\n\nWhen developing server-side applications, the message type you're most likely to create manually is\nthe response. In such cases, the standard signature can be an obstacle to usability. Let's review:\n\n\nclass Response implements ResponseInterface\n{\n    public function __construct($body = 'php://temp', $status = 200, array $headers = []);\n}\n\n\n\nSome standard use cases, however, make this un-wieldy:\n\n\n\n\nReturning a response containing HTML; in this case, you likely want to provide the HTML to the\n  constructor, not a stream with the HTML injected.\n\n\nReturning a response containing JSON; in this case, you likely want to provide the data to\n  serialize to JSON, not a stream containing serialized JSON.\n\n\nReturning a response with no content; in this case, you don't want to bother with the body at all.\n\n\nReturning a redirect response; in this case, you likely just want to specify the target for the\n  \nLocation\n header, and optionally the status code.\n\n\n\n\nStarting with version 1.1, Diactoros offers several custom response types for simplifying these\ncommon tasks.\n\n\nText Responses\n\n\nZend\\Diactoros\\Response\\TextResponse\n creates a plain text response. It sets the\n\nContent-Type\n header to \ntext/plain\n by default:\n\n\n$response = new TextResponse('Hello world!');\n\n\n\nThe constructor accepts two additional arguments: a status code and an array of headers.\n\n\n$response = new TextResponse($text, 200, ['Content-Type' => ['text/csv']]);\n\n\n\nHTML Responses\n\n\nZend\\Diactoros\\Response\\HtmlResponse\n allows specifying HTML as a payload, and sets the\n\nContent-Type\n header to \ntext/html\n by default:\n\n\n$response = new HtmlResponse($htmlContent);\n\n\n\nThe constructor allows passing two additional arguments: a status code, and an array of headers.\nThese allow you to further seed the initial state of the response, as well as to override the\n\nContent-Type\n header if desired:\n\n\n$response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' => ['application/xhtml+xml']]);\n\n\n\nHeaders must be in the same format as you would provide to the\n\nResponse constructor\n.\n\n\nXML Responses\n\n\n\n\nSince 1.7.0\n\n\n\n\nZend\\Diactoros\\Response\\XmlResponse\n allows specifying XML as a payload, and sets the\n\nContent-Type\n header to \napplication/xml\n by default:\n\n\n$response = new XmlResponse($xml);\n\n\n\nThe constructor allows passing two additional arguments: a status code, and an array of headers.\nThese allow you to further seed the initial state of the response, as well as to override the\n\nContent-Type\n header if desired:\n\n\n$response = new XmlResponse($xml, 200, [ 'Content-Type' => ['application/hal+xml']]);\n\n\n\nHeaders must be in the same format as you would provide to the\n\nResponse constructor\n.\n\n\nJSON Responses\n\n\nZend\\Diactoros\\Response\\JsonResponse\n accepts a data structure to convert to JSON, and sets\nthe \nContent-Type\n header to \napplication/json\n:\n\n\n$response = new JsonResponse($data);\n\n\n\nIf providing an object, we recommend implementing \nJsonSerializable\n\nto ensure your object is correctly serialized.\n\n\nJust like the \nHtmlResponse\n, the \nJsonResponse\n allows passing two additional arguments \u2014 a\nstatus code, and an array of headers \u2014 to allow you to further seed the initial state of the\nresponse:\n\n\n$response = new JsonResponse($data, 200, [ 'Content-Type' => ['application/hal+json']]);\n\n\n\nFinally, \nJsonResponse\n allows a fourth optional argument, the flags to provide to \njson_encode()\n.\nBy default, these are set to \nJSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT\n (integer\n15), providing \nRFC 4627\n compliant JSON capable of embedding in\nHTML. If you want to specify a different set of flags, use the fourth constructor argument:\n\n\n$response = new JsonResponse(\n    $data,\n    200,\n    [],\n    JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT\n);\n\n\n\nEmpty Responses\n\n\nMany API actions allow returning empty responses:\n\n\n\n\n201 Created\n responses are often empty, and only include a \nLink\n or \nLocation\n header pointing\n  to the newly created resource.\n\n\n202 Accepted\n responses are typically empty, indicating that the new entity has been received,\n  but not yet processed.\n\n\n204 No Content\n responses are, by definition, empty, and often used as a success response when\n  deleting an entity.\n\n\n\n\nZend\\Diactoros\\Response\\EmptyResponse\n is a \nZend\\Diactoros\\Response\n extension that, by default,\nreturns an empty response with a 204 status. Its constructor allows passing the status and headers\nonly:\n\n\nclass EmptyResponse extends Response\n{\n    public function __construct($status = 204, array $headers = []);\n}\n\n\n\nAn empty, read-only body is injected at instantiation, ensuring no write operations are possible on\nthe response. Usage is typically one of the following forms:\n\n\n// Basic 204 response:\n$response = new EmptyResponse();\n\n// 201 response with location header:\n$response = new EmptyResponse(201, [\n    'Location' => [ $url ],\n]);\n\n// Alternately, set the header after instantiation:\n$response = ( new EmptyResponse(201) )->withHeader('Location', $url);\n\n\n\nRedirects\n\n\nZend\\Diactoros\\Response\\RedirectResponse\n is a \nZend\\Diactoros\\Response\n extension for producing\nredirect responses. The only required argument is a URI, which may be provided as either a string or\n\nPsr\\Http\\Message\\UriInterface\n instance. By default, the status 302 is used, and no other headers\nare produced; you may alter these via the additional optional arguments:\n\n\nclass RedirectResponse extends Response\n{\n    public function __construct($uri, $status = 302, array $headers = []);\n}\n\n\n\nTypical usage is:\n\n\n// 302 redirect:\n$response = new RedirectResponse('/user/login');\n\n// 301 redirect:\n$response = new RedirectResponse('/user/login', 301);\n\n// using a URI instance (e.g., by altering the request URI instance)\n$uri = $request->getUri();\n$response = new RedirectResponse($uri->withPath('/login'));\n\n\n\nCreating custom responses\n\n\nPHP allows constructor overloading. What this means is that constructors of extending classes can\ndefine completely different argument sets without conflicting with the parent implementation.\nConsidering that most custom response types do not need to change internal functionality, but\ninstead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to\ncreate your custom types.\n\n\nThe general pattern will be something like this:\n\n\nclass MyCustomResponse extends Response\n{\n    public function __construct($data, $status = 200, array $headers = [])\n    {\n        // - Do something with $data, and create a Stream for the body (if necessary).\n        // - Maybe set some default headers.\n\n        parent::__construct($body, $status, $headers);\n    }\n}\n\n\n\nNote the call to \nparent::__construct()\n. This is particularly relevant, as the implementation at\nthe time of writing has all class properties marked as private, making them inaccessible to\nextensions; this is done to protect encapsulation and ensure consistency of operations between\ninstances.\n\n\nIf you don't want to go the extension route (perhaps you don't want another \nResponseInterface\n\nimplementation within your object graph) you can instead create a factory. As an example:\n\n\n$plainTextResponse = function ($text, $status = 200, array $headers = []) {\n    $response = new Response('php://temp', $status, $headers);\n    $response->getBody()->write($text);\n    if (! $response->hasHeader('Content-Type')) {\n        $response = $response->withHeader('Content-Type', 'text/plain');\n    }\n    return $response;\n};\n\n$response = $plainTextResponse('Hello, world!');\n\n\n\nWe recommend following the semantic of providing the status and headers as the final two arguments\nfor any factory or custom response extensions.",
            "title": "Custom Responses"
        },
        {
            "location": "/v1/custom-responses/#custom-responses",
            "text": "When developing server-side applications, the message type you're most likely to create manually is\nthe response. In such cases, the standard signature can be an obstacle to usability. Let's review:  class Response implements ResponseInterface\n{\n    public function __construct($body = 'php://temp', $status = 200, array $headers = []);\n}  Some standard use cases, however, make this un-wieldy:   Returning a response containing HTML; in this case, you likely want to provide the HTML to the\n  constructor, not a stream with the HTML injected.  Returning a response containing JSON; in this case, you likely want to provide the data to\n  serialize to JSON, not a stream containing serialized JSON.  Returning a response with no content; in this case, you don't want to bother with the body at all.  Returning a redirect response; in this case, you likely just want to specify the target for the\n   Location  header, and optionally the status code.   Starting with version 1.1, Diactoros offers several custom response types for simplifying these\ncommon tasks.",
            "title": "Custom Responses"
        },
        {
            "location": "/v1/custom-responses/#text-responses",
            "text": "Zend\\Diactoros\\Response\\TextResponse  creates a plain text response. It sets the Content-Type  header to  text/plain  by default:  $response = new TextResponse('Hello world!');  The constructor accepts two additional arguments: a status code and an array of headers.  $response = new TextResponse($text, 200, ['Content-Type' => ['text/csv']]);",
            "title": "Text Responses"
        },
        {
            "location": "/v1/custom-responses/#html-responses",
            "text": "Zend\\Diactoros\\Response\\HtmlResponse  allows specifying HTML as a payload, and sets the Content-Type  header to  text/html  by default:  $response = new HtmlResponse($htmlContent);  The constructor allows passing two additional arguments: a status code, and an array of headers.\nThese allow you to further seed the initial state of the response, as well as to override the Content-Type  header if desired:  $response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' => ['application/xhtml+xml']]);  Headers must be in the same format as you would provide to the Response constructor .",
            "title": "HTML Responses"
        },
        {
            "location": "/v1/custom-responses/#xml-responses",
            "text": "Since 1.7.0   Zend\\Diactoros\\Response\\XmlResponse  allows specifying XML as a payload, and sets the Content-Type  header to  application/xml  by default:  $response = new XmlResponse($xml);  The constructor allows passing two additional arguments: a status code, and an array of headers.\nThese allow you to further seed the initial state of the response, as well as to override the Content-Type  header if desired:  $response = new XmlResponse($xml, 200, [ 'Content-Type' => ['application/hal+xml']]);  Headers must be in the same format as you would provide to the Response constructor .",
            "title": "XML Responses"
        },
        {
            "location": "/v1/custom-responses/#json-responses",
            "text": "Zend\\Diactoros\\Response\\JsonResponse  accepts a data structure to convert to JSON, and sets\nthe  Content-Type  header to  application/json :  $response = new JsonResponse($data);  If providing an object, we recommend implementing  JsonSerializable \nto ensure your object is correctly serialized.  Just like the  HtmlResponse , the  JsonResponse  allows passing two additional arguments \u2014 a\nstatus code, and an array of headers \u2014 to allow you to further seed the initial state of the\nresponse:  $response = new JsonResponse($data, 200, [ 'Content-Type' => ['application/hal+json']]);  Finally,  JsonResponse  allows a fourth optional argument, the flags to provide to  json_encode() .\nBy default, these are set to  JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT  (integer\n15), providing  RFC 4627  compliant JSON capable of embedding in\nHTML. If you want to specify a different set of flags, use the fourth constructor argument:  $response = new JsonResponse(\n    $data,\n    200,\n    [],\n    JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT\n);",
            "title": "JSON Responses"
        },
        {
            "location": "/v1/custom-responses/#empty-responses",
            "text": "Many API actions allow returning empty responses:   201 Created  responses are often empty, and only include a  Link  or  Location  header pointing\n  to the newly created resource.  202 Accepted  responses are typically empty, indicating that the new entity has been received,\n  but not yet processed.  204 No Content  responses are, by definition, empty, and often used as a success response when\n  deleting an entity.   Zend\\Diactoros\\Response\\EmptyResponse  is a  Zend\\Diactoros\\Response  extension that, by default,\nreturns an empty response with a 204 status. Its constructor allows passing the status and headers\nonly:  class EmptyResponse extends Response\n{\n    public function __construct($status = 204, array $headers = []);\n}  An empty, read-only body is injected at instantiation, ensuring no write operations are possible on\nthe response. Usage is typically one of the following forms:  // Basic 204 response:\n$response = new EmptyResponse();\n\n// 201 response with location header:\n$response = new EmptyResponse(201, [\n    'Location' => [ $url ],\n]);\n\n// Alternately, set the header after instantiation:\n$response = ( new EmptyResponse(201) )->withHeader('Location', $url);",
            "title": "Empty Responses"
        },
        {
            "location": "/v1/custom-responses/#redirects",
            "text": "Zend\\Diactoros\\Response\\RedirectResponse  is a  Zend\\Diactoros\\Response  extension for producing\nredirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface  instance. By default, the status 302 is used, and no other headers\nare produced; you may alter these via the additional optional arguments:  class RedirectResponse extends Response\n{\n    public function __construct($uri, $status = 302, array $headers = []);\n}  Typical usage is:  // 302 redirect:\n$response = new RedirectResponse('/user/login');\n\n// 301 redirect:\n$response = new RedirectResponse('/user/login', 301);\n\n// using a URI instance (e.g., by altering the request URI instance)\n$uri = $request->getUri();\n$response = new RedirectResponse($uri->withPath('/login'));",
            "title": "Redirects"
        },
        {
            "location": "/v1/custom-responses/#creating-custom-responses",
            "text": "PHP allows constructor overloading. What this means is that constructors of extending classes can\ndefine completely different argument sets without conflicting with the parent implementation.\nConsidering that most custom response types do not need to change internal functionality, but\ninstead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to\ncreate your custom types.  The general pattern will be something like this:  class MyCustomResponse extends Response\n{\n    public function __construct($data, $status = 200, array $headers = [])\n    {\n        // - Do something with $data, and create a Stream for the body (if necessary).\n        // - Maybe set some default headers.\n\n        parent::__construct($body, $status, $headers);\n    }\n}  Note the call to  parent::__construct() . This is particularly relevant, as the implementation at\nthe time of writing has all class properties marked as private, making them inaccessible to\nextensions; this is done to protect encapsulation and ensure consistency of operations between\ninstances.  If you don't want to go the extension route (perhaps you don't want another  ResponseInterface \nimplementation within your object graph) you can instead create a factory. As an example:  $plainTextResponse = function ($text, $status = 200, array $headers = []) {\n    $response = new Response('php://temp', $status, $headers);\n    $response->getBody()->write($text);\n    if (! $response->hasHeader('Content-Type')) {\n        $response = $response->withHeader('Content-Type', 'text/plain');\n    }\n    return $response;\n};\n\n$response = $plainTextResponse('Hello, world!');  We recommend following the semantic of providing the status and headers as the final two arguments\nfor any factory or custom response extensions.",
            "title": "Creating custom responses"
        },
        {
            "location": "/v1/emitting-responses/",
            "text": "Emitting responses\n\n\n\n\nDeprecated\n\n\nEmitters are deprecated from Diactoros starting with version 1.8.0. The\nfunctionality is now available for any PSR-7 implementation via the package\n\nzendframework/zend-httphandlerrunner\n.\nWe suggest using that functionality instead.\n\n\n\n\nIf you are using a non-SAPI PHP implementation and wish to use the \nServer\n class, or if you do not\nwant to use the \nServer\n implementation but want to emit a response, this package provides an\ninterface, \nZend\\Diactoros\\Response\\EmitterInterface\n, defining a method \nemit()\n for emitting the\nresponse.\n\n\nDiactoros provides two implementations currently, both for working with\ntraditional Server API (SAPI) implementations: \nZend\\Diactoros\\Response\\SapiEmitter\n\nand \nZend\\Diactoros\\Response\\SapiStreamEmitter\n.  Each uses the native \nheader()\n\nPHP function to emit headers, and \necho()\n to emit the response body.\n\n\nIf you are using a non-SAPI implementation, you will need to create your own\n\nEmitterInterface\n implementation.\n\n\nFor example, the \nSapiEmitter\n implementation of the \nEmitterInterface\n can be used thus:\n\n\n$response = new Zend\\Diactoros\\Response();\n$response->getBody()->write(\"some content\\n\");\n$emitter = new Zend\\Diactoros\\Response\\SapiEmitter();\n$emitter->emit($response);\n\n\n\nEmitting ranges of streamed files\n\n\nThe \nSapiStreamEmitter\n is useful when you want to emit a \nContent-Range\n. As an\nexample, to stream a range of bytes from a file to a client, the client can pass\nthe following header:\n\n\nRange: bytes=1024-2047\n\n\n\nYour application would then populate the response with a \nContent-Range\n header:\n\n\n$range = $request->getHeaderLine('range');\n$range = str_replace('=', ' ', $range);\n\n$body = new Stream($pathToFile);\n$size = $body->getSize();\n$range .= '/' . $size;\n\n$response = new Response($body);\n$response = $response->withHeader('Content-Range', $range);\n\n\n\n\n\nNote: you will likely want to ensure the range specified falls within the\ncontent size of the streamed body!\n\n\n\n\nThe \nSapiStreamEmitter\n detects the \nContent-Range\n header and emits only the\nbytes specified.\n\n\n$emitter = new SapiStreamEmitter();\n$emitter->emit($response);\n\n\n\nThe \nSapiStreamEmitter\n may be used in place of the \nSapiEmitter\n, even when not\nsending files. However, unlike the \nSapiEmitter\n, it will emit a chunk of\ncontent at a time instead of the full content at once, which could lead to\nperformance overhead. The default chunk size is 8192 bytes.",
            "title": "Emitting Responses"
        },
        {
            "location": "/v1/emitting-responses/#emitting-responses",
            "text": "",
            "title": "Emitting responses"
        },
        {
            "location": "/v1/emitting-responses/#deprecated",
            "text": "Emitters are deprecated from Diactoros starting with version 1.8.0. The\nfunctionality is now available for any PSR-7 implementation via the package zendframework/zend-httphandlerrunner .\nWe suggest using that functionality instead.   If you are using a non-SAPI PHP implementation and wish to use the  Server  class, or if you do not\nwant to use the  Server  implementation but want to emit a response, this package provides an\ninterface,  Zend\\Diactoros\\Response\\EmitterInterface , defining a method  emit()  for emitting the\nresponse.  Diactoros provides two implementations currently, both for working with\ntraditional Server API (SAPI) implementations:  Zend\\Diactoros\\Response\\SapiEmitter \nand  Zend\\Diactoros\\Response\\SapiStreamEmitter .  Each uses the native  header() \nPHP function to emit headers, and  echo()  to emit the response body.  If you are using a non-SAPI implementation, you will need to create your own EmitterInterface  implementation.  For example, the  SapiEmitter  implementation of the  EmitterInterface  can be used thus:  $response = new Zend\\Diactoros\\Response();\n$response->getBody()->write(\"some content\\n\");\n$emitter = new Zend\\Diactoros\\Response\\SapiEmitter();\n$emitter->emit($response);",
            "title": "Deprecated"
        },
        {
            "location": "/v1/emitting-responses/#emitting-ranges-of-streamed-files",
            "text": "The  SapiStreamEmitter  is useful when you want to emit a  Content-Range . As an\nexample, to stream a range of bytes from a file to a client, the client can pass\nthe following header:  Range: bytes=1024-2047  Your application would then populate the response with a  Content-Range  header:  $range = $request->getHeaderLine('range');\n$range = str_replace('=', ' ', $range);\n\n$body = new Stream($pathToFile);\n$size = $body->getSize();\n$range .= '/' . $size;\n\n$response = new Response($body);\n$response = $response->withHeader('Content-Range', $range);   Note: you will likely want to ensure the range specified falls within the\ncontent size of the streamed body!   The  SapiStreamEmitter  detects the  Content-Range  header and emits only the\nbytes specified.  $emitter = new SapiStreamEmitter();\n$emitter->emit($response);  The  SapiStreamEmitter  may be used in place of the  SapiEmitter , even when not\nsending files. However, unlike the  SapiEmitter , it will emit a chunk of\ncontent at a time instead of the full content at once, which could lead to\nperformance overhead. The default chunk size is 8192 bytes.",
            "title": "Emitting ranges of streamed files"
        },
        {
            "location": "/v1/serialization/",
            "text": "Serialization\n\n\nString\n\n\nAt times, it's useful to either create a string representation of a message (serialization), or to\ncast a string or stream message to an object (deserialization). This package provides features for\nthis in \nZend\\Diactoros\\Request\\Serializer\n and \nZend\\Diactoros\\Response\\Serializer\n; each provides\nthe following static methods:\n\n\n\n\nfromString($message)\n will create either a \nRequest\n or \nResponse\n instance (based on the\n  serializer used) from the string message.\n\n\nfromStream(Psr\\Http\\Message\\StreamInterface $stream)\n will create either a \nRequest\n or\n  \nResponse\n instance (based on the serializer used) from the provided stream.\n\n\ntoString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)\n will\n  create either a string from the provided message.\n\n\n\n\nThe deserialization methods (\nfrom*()\n) will raise exceptions if errors occur while parsing the\nmessage. The serialization methods (\ntoString()\n) will raise exceptions if required data for\nserialization is not present in the message instance.\n\n\nArray\n\n\nThis package also provides features for array serialization using\n\nZend\\Diactoros\\Request\\ArraySerializer\n and \nZend\\Diactoros\\Response\\ArraySerializer\n; each provides\nthe following static methods:\n\n\n\n\nfromArray(array $message)\n will create either a \nRequest\n or \nResponse\n instance (based on the\n  serializer used) from the array message.\n\n\ntoArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)\n will\n  create an array from the provided message.\n\n\n\n\nThe deserialization methods (\nfromArray()\n) will raise exceptions if errors occur while parsing the\nmessage.\n\n\nExample usage\n\n\nArray serialization can be usesful for log messages:\n\n\nclass LoggerMiddleware\n{\n    /**\n     * @var \\Psr\\Log\\LoggerInterface\n     */\n    protected $logger;\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $response = $next($request, $response);\n\n        $this->logger->debug('Request/Response', [\n            'request' => \\Zend\\Diactoros\\Request\\ArraySerializer::toArray($request),\n            'response' => \\Zend\\Diactoros\\Response\\ArraySerializer::toArray($response),\n        ]);\n\n        return $response;\n    }\n}",
            "title": "Serialization"
        },
        {
            "location": "/v1/serialization/#serialization",
            "text": "",
            "title": "Serialization"
        },
        {
            "location": "/v1/serialization/#string",
            "text": "At times, it's useful to either create a string representation of a message (serialization), or to\ncast a string or stream message to an object (deserialization). This package provides features for\nthis in  Zend\\Diactoros\\Request\\Serializer  and  Zend\\Diactoros\\Response\\Serializer ; each provides\nthe following static methods:   fromString($message)  will create either a  Request  or  Response  instance (based on the\n  serializer used) from the string message.  fromStream(Psr\\Http\\Message\\StreamInterface $stream)  will create either a  Request  or\n   Response  instance (based on the serializer used) from the provided stream.  toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)  will\n  create either a string from the provided message.   The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the\nmessage. The serialization methods ( toString() ) will raise exceptions if required data for\nserialization is not present in the message instance.",
            "title": "String"
        },
        {
            "location": "/v1/serialization/#array",
            "text": "This package also provides features for array serialization using Zend\\Diactoros\\Request\\ArraySerializer  and  Zend\\Diactoros\\Response\\ArraySerializer ; each provides\nthe following static methods:   fromArray(array $message)  will create either a  Request  or  Response  instance (based on the\n  serializer used) from the array message.  toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message)  will\n  create an array from the provided message.   The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the\nmessage.",
            "title": "Array"
        },
        {
            "location": "/v1/serialization/#example-usage",
            "text": "Array serialization can be usesful for log messages:  class LoggerMiddleware\n{\n    /**\n     * @var \\Psr\\Log\\LoggerInterface\n     */\n    protected $logger;\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $response = $next($request, $response);\n\n        $this->logger->debug('Request/Response', [\n            'request' => \\Zend\\Diactoros\\Request\\ArraySerializer::toArray($request),\n            'response' => \\Zend\\Diactoros\\Response\\ArraySerializer::toArray($response),\n        ]);\n\n        return $response;\n    }\n}",
            "title": "Example usage"
        },
        {
            "location": "/v1/api/",
            "text": "API\n\n\nRequest Message\n\n\nZend\\Diactoros\\Request\n implements \nPsr\\Http\\Message\\RequestInterface\n,\nand is intended for client-side requests. It includes the following methods:\n\n\nclass Request\n{\n    public function __construct(\n        $uri = null,\n        $method = null,\n        $body = 'php://memory',\n        array $headers = []\n    );\n\n    // See psr/http-message's RequestInterface for other methods\n}\n\n\n\nRequests are immutable. Any methods that would change state \u2014 those prefixed with \nwith\n and\n\nwithout\n \u2014 all return a new instance with the changes requested.\n\n\nServerRequest Message\n\n\nFor server-side applications, \nZend\\Diactoros\\ServerRequest\n implements\n\nPsr\\Http\\Message\\ServerRequestInterface\n,\nwhich provides access to the elements of an HTTP request, as well as uniform access to the various\nelements of incoming data. The methods included are:\n\n\nclass ServerRequest\n{\n    public function __construct(\n        array $serverParams = [],\n        array $fileParams = [],\n        $uri = null,\n        $method = null,\n        $body = 'php://input',\n        array $headers = []\n    );\n\n    // See psr/http-message's ServerRequestInterface for other methods.\n}\n\n\n\nThe \nServerRequest\n is immutable. Any methods that would change state \u2014 those prefixed with \nwith\n\nand \nwithout\n \u2014 all return a new instance with the changes requested. Server parameters are\nconsidered completely immutable, however, as they cannot be recalculated, and, rather, is a source\nfor other values.\n\n\nResponse Message\n\n\nZend\\Diactoros\\Response\n provides an implementation of\n\nPsr\\Http\\Message\\ResponseInterface\n,\nan object to be used to aggregate response information for both HTTP clients and server-side\napplications, including headers and message body content. It includes the following:\n\n\nclass Response\n{\n    public function __construct(\n        $body = 'php://memory',\n        $statusCode = 200,\n        array $headers = []\n    );\n\n    // See psr/http-message's ResponseInterface for other methods\n}\n\n\n\nLike the \nRequest\n and \nServerRequest\n, responses are immutable. Any methods that would change state\n\u2014 those prefixed with \nwith\n and \nwithout\n \u2014 all return a new instance with the changes requested.\n\n\nHtmlResponse and JsonResponse\n\n\n\n\nAdded in 1.1.0\n\n\n\n\nThe most common use case in server-side applications for generating responses is to provide a string\nto use for the response, typically HTML or data to serialize as JSON.  \nZend\\Diactoros\\Response\\HtmlResponse\n and \nZend\\Diactoros\\Response\\JsonResponse\n exist to facilitate these use cases:\n\n\n$htmlResponse = new HtmlResponse($html);\n\n$jsonResponse = new JsonResponse($data);\n\n\n\nIn the first example, you will receive a response with a stream containing the HTML; additionally,\nthe \nContent-Type\n header will be set to \ntext/html\n. In the second case, the stream will contain a\nstream containing the JSON-serialized \n$data\n, and have a \nContent-Type\n header set to\n\napplication/json\n.\n\n\nBoth objects allow passing the HTTP status, as well as any headers you want to specify,\nincluding the \nContent-Type\n header:\n\n\n$htmlResponse = new HtmlResponse($html, 404, [\n    'Content-Type' => [ 'application/xhtml+xml' ],\n]);\n\n$jsonResponse = new JsonResponse($data, 422, [\n    'Content-Type' => [ 'application/problem+json' ],\n]);\n\n\n\nServerRequestFactory\n\n\nThis static class can be used to marshal a \nServerRequest\n instance from the PHP environment. The\nprimary entry point is \nZend\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array\n$query, array $body, array $cookies, array $files)\n. This method will create a new \nServerRequest\n\ninstance with the data provided. Examples of usage are:\n\n\n// Returns new ServerRequest instance, using values from superglobals:\n$request = ServerRequestFactory::fromGlobals();\n\n// or\n\n// Returns new ServerRequest instance, using values provided (in this\n// case, equivalent to the previous!)\n$request = RequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);\n\n\n\nServerRequestFactory helper functions\n\n\n\n\nSince 1.8.0\n\n\n\n\nIn order to create the various artifacts required by a \nServerRequest\n instance,\nDiactoros also provides a number of functions under the \nZend\\Diactoros\n\nnamespace for introspecting the SAPI \n$_SERVER\n parameters, headers, \n$_FILES\n,\nand even the \nCookie\n header. These include:\n\n\n\n\nZend\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array\n\n  (its main purpose is to aggregate the \nAuthorization\n header in the SAPI params\n  when under Apache)\n\n\nZend\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string\n\n\nZend\\Diactoros\\marshalMethodFromSapi(array $server) : string\n\n\nZend\\Diactoros\\marshalUriFromSapi(array $server, array $headers) : Uri\n\n\nZend\\Diactoros\\marshalHeadersFromSapi(array $server) : array\n\n\nZend\\Diactoros\\parseCookieHeader(string $header) : array\n\n\nZend\\Diactoros\\createUploadedFile(array $spec) : UploadedFile\n (creates the\n  instance from a normal \n$_FILES\n entry)\n\n\nZend\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[]\n\n  (traverses a potentially nested array of uploaded file instances and/or\n  \n$_FILES\n entries, including those aggregated under mod_php, php-fpm, and\n  php-cgi in order to create a flat array of \nUploadedFileInterface\n instances\n  to use in a request)\n\n\n\n\nURI\n\n\nZend\\Diactoros\\Uri\n is an implementation of\n\nPsr\\Http\\Message\\UriInterface\n,\nand models and validates URIs. It implements \n__toString()\n, allowing it to be represented as a\nstring and \necho()\n'd directly. The following methods are pertinent:\n\n\nclass Uri\n{\n    public function __construct($uri = '');\n\n    // See psr/http-message's UriInterface for other methods.\n}\n\n\n\nLike the various message objects, URIs are immutable. Any methods that would\nchange state \u2014 those\nprefixed with \nwith\n and \nwithout\n \u2014 all return a new instance with the changes requested.\n\n\nStream\n\n\nZend\\Diactoros\\Stream\n is an implementation of\n\nPsr\\Http\\Message\\StreamInterface\n,\nand provides a number of facilities around manipulating the composed PHP stream resource. The\nconstructor accepts a stream, which may be either:\n\n\n\n\na stream identifier; e.g., \nphp://input\n, a filename, etc.\n\n\na PHP stream resource\n\n\n\n\nIf a stream identifier is provided, an optional second parameter may be provided, the file mode by\nwhich to \nfopen\n the stream.\n\n\nServerRequest\n objects by default use a \nphp://input\n stream set to read-only; \nResponse\n objects\nby default use a \nphp://memory\n with a mode of \nwb+\n, allowing binary read/write access.\n\n\nIn most cases, you will not interact with the Stream object directly.\n\n\nUploadedFile\n\n\nZend\\Diactoros\\UploadedFile\n is an implementation of\n\nPsr\\Http\\Message\\UploadedFileInterface\n,\nand provides abstraction around a single uploaded file, including behavior for interacting with it\nas a stream or moving it to a filesystem location.\n\n\nIn most cases, you will only use the methods defined in the \nUploadedFileInterface\n.\n\n\nServer\n\n\n\n\nDeprecated\n\n\nThe class \nZend\\Diactoros\\Server\n is deprecated as of the 1.8.0 release. We\nrecommend using the class \nZend\\HttpHandlerRunner\\RequestHandlerRunner\n via\nthe package \nzendframework/zend-httphandlerrunner\n\ninstead.\n\n\n\n\nZend\\Diactoros\\Server\n represents a server capable of executing a callback. It has four methods:\n\n\nclass Server\n{\n    public function __construct(\n        callable $callback,\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    );\n    public static function createServer(\n        callable $callback,\n        array $server,  // usually $_SERVER\n        array $query,   // usually $_GET\n        array $body,    // usually $_POST\n        array $cookies, // usually $_COOKIE\n        array $files    // usually $_FILES\n    );\n    public static function createServerFromRequest(\n        callable $callback,\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response = null\n    );\n    public function setEmitter(Response\\EmitterInterface $emitter);\n    public function listen(callable $finalHandler = null);\n}\n\n\n\nYou can create an instance of the \nServer\n using any of the constructor, \ncreateServer()\n, or\n\ncreateServerFromRequest()\n methods. If you wish to use the default request and response\nimplementations, \ncreateServer($middleware, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES)\n is the\nrecommended option, as this method will also marshal the \nServerRequest\n object based on the PHP\nrequest environment.  If you wish to use your own implementations, pass them to the constructor or\n\ncreateServerFromRequest()\n method (the latter will create a default \nResponse\n instance if you omit\nit).\n\n\nlisten()\n executes the callback. If a \n$finalHandler\n is provided, it will be passed as the third\nargument to the \n$callback\n registered with the server.",
            "title": "API"
        },
        {
            "location": "/v1/api/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/v1/api/#request-message",
            "text": "Zend\\Diactoros\\Request  implements  Psr\\Http\\Message\\RequestInterface ,\nand is intended for client-side requests. It includes the following methods:  class Request\n{\n    public function __construct(\n        $uri = null,\n        $method = null,\n        $body = 'php://memory',\n        array $headers = []\n    );\n\n    // See psr/http-message's RequestInterface for other methods\n}  Requests are immutable. Any methods that would change state \u2014 those prefixed with  with  and without  \u2014 all return a new instance with the changes requested.",
            "title": "Request Message"
        },
        {
            "location": "/v1/api/#serverrequest-message",
            "text": "For server-side applications,  Zend\\Diactoros\\ServerRequest  implements Psr\\Http\\Message\\ServerRequestInterface ,\nwhich provides access to the elements of an HTTP request, as well as uniform access to the various\nelements of incoming data. The methods included are:  class ServerRequest\n{\n    public function __construct(\n        array $serverParams = [],\n        array $fileParams = [],\n        $uri = null,\n        $method = null,\n        $body = 'php://input',\n        array $headers = []\n    );\n\n    // See psr/http-message's ServerRequestInterface for other methods.\n}  The  ServerRequest  is immutable. Any methods that would change state \u2014 those prefixed with  with \nand  without  \u2014 all return a new instance with the changes requested. Server parameters are\nconsidered completely immutable, however, as they cannot be recalculated, and, rather, is a source\nfor other values.",
            "title": "ServerRequest Message"
        },
        {
            "location": "/v1/api/#response-message",
            "text": "Zend\\Diactoros\\Response  provides an implementation of Psr\\Http\\Message\\ResponseInterface ,\nan object to be used to aggregate response information for both HTTP clients and server-side\napplications, including headers and message body content. It includes the following:  class Response\n{\n    public function __construct(\n        $body = 'php://memory',\n        $statusCode = 200,\n        array $headers = []\n    );\n\n    // See psr/http-message's ResponseInterface for other methods\n}  Like the  Request  and  ServerRequest , responses are immutable. Any methods that would change state\n\u2014 those prefixed with  with  and  without  \u2014 all return a new instance with the changes requested.",
            "title": "Response Message"
        },
        {
            "location": "/v1/api/#htmlresponse-and-jsonresponse",
            "text": "Added in 1.1.0   The most common use case in server-side applications for generating responses is to provide a string\nto use for the response, typically HTML or data to serialize as JSON.   Zend\\Diactoros\\Response\\HtmlResponse  and  Zend\\Diactoros\\Response\\JsonResponse  exist to facilitate these use cases:  $htmlResponse = new HtmlResponse($html);\n\n$jsonResponse = new JsonResponse($data);  In the first example, you will receive a response with a stream containing the HTML; additionally,\nthe  Content-Type  header will be set to  text/html . In the second case, the stream will contain a\nstream containing the JSON-serialized  $data , and have a  Content-Type  header set to application/json .  Both objects allow passing the HTTP status, as well as any headers you want to specify,\nincluding the  Content-Type  header:  $htmlResponse = new HtmlResponse($html, 404, [\n    'Content-Type' => [ 'application/xhtml+xml' ],\n]);\n\n$jsonResponse = new JsonResponse($data, 422, [\n    'Content-Type' => [ 'application/problem+json' ],\n]);",
            "title": "HtmlResponse and JsonResponse"
        },
        {
            "location": "/v1/api/#serverrequestfactory",
            "text": "This static class can be used to marshal a  ServerRequest  instance from the PHP environment. The\nprimary entry point is  Zend\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array\n$query, array $body, array $cookies, array $files) . This method will create a new  ServerRequest \ninstance with the data provided. Examples of usage are:  // Returns new ServerRequest instance, using values from superglobals:\n$request = ServerRequestFactory::fromGlobals();\n\n// or\n\n// Returns new ServerRequest instance, using values provided (in this\n// case, equivalent to the previous!)\n$request = RequestFactory::fromGlobals(\n    $_SERVER,\n    $_GET,\n    $_POST,\n    $_COOKIE,\n    $_FILES\n);",
            "title": "ServerRequestFactory"
        },
        {
            "location": "/v1/api/#serverrequestfactory-helper-functions",
            "text": "Since 1.8.0   In order to create the various artifacts required by a  ServerRequest  instance,\nDiactoros also provides a number of functions under the  Zend\\Diactoros \nnamespace for introspecting the SAPI  $_SERVER  parameters, headers,  $_FILES ,\nand even the  Cookie  header. These include:   Zend\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array \n  (its main purpose is to aggregate the  Authorization  header in the SAPI params\n  when under Apache)  Zend\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string  Zend\\Diactoros\\marshalMethodFromSapi(array $server) : string  Zend\\Diactoros\\marshalUriFromSapi(array $server, array $headers) : Uri  Zend\\Diactoros\\marshalHeadersFromSapi(array $server) : array  Zend\\Diactoros\\parseCookieHeader(string $header) : array  Zend\\Diactoros\\createUploadedFile(array $spec) : UploadedFile  (creates the\n  instance from a normal  $_FILES  entry)  Zend\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[] \n  (traverses a potentially nested array of uploaded file instances and/or\n   $_FILES  entries, including those aggregated under mod_php, php-fpm, and\n  php-cgi in order to create a flat array of  UploadedFileInterface  instances\n  to use in a request)",
            "title": "ServerRequestFactory helper functions"
        },
        {
            "location": "/v1/api/#uri",
            "text": "Zend\\Diactoros\\Uri  is an implementation of Psr\\Http\\Message\\UriInterface ,\nand models and validates URIs. It implements  __toString() , allowing it to be represented as a\nstring and  echo() 'd directly. The following methods are pertinent:  class Uri\n{\n    public function __construct($uri = '');\n\n    // See psr/http-message's UriInterface for other methods.\n}  Like the various message objects, URIs are immutable. Any methods that would\nchange state \u2014 those\nprefixed with  with  and  without  \u2014 all return a new instance with the changes requested.",
            "title": "URI"
        },
        {
            "location": "/v1/api/#stream",
            "text": "Zend\\Diactoros\\Stream  is an implementation of Psr\\Http\\Message\\StreamInterface ,\nand provides a number of facilities around manipulating the composed PHP stream resource. The\nconstructor accepts a stream, which may be either:   a stream identifier; e.g.,  php://input , a filename, etc.  a PHP stream resource   If a stream identifier is provided, an optional second parameter may be provided, the file mode by\nwhich to  fopen  the stream.  ServerRequest  objects by default use a  php://input  stream set to read-only;  Response  objects\nby default use a  php://memory  with a mode of  wb+ , allowing binary read/write access.  In most cases, you will not interact with the Stream object directly.",
            "title": "Stream"
        },
        {
            "location": "/v1/api/#uploadedfile",
            "text": "Zend\\Diactoros\\UploadedFile  is an implementation of Psr\\Http\\Message\\UploadedFileInterface ,\nand provides abstraction around a single uploaded file, including behavior for interacting with it\nas a stream or moving it to a filesystem location.  In most cases, you will only use the methods defined in the  UploadedFileInterface .",
            "title": "UploadedFile"
        },
        {
            "location": "/v1/api/#server",
            "text": "",
            "title": "Server"
        },
        {
            "location": "/v1/api/#deprecated",
            "text": "The class  Zend\\Diactoros\\Server  is deprecated as of the 1.8.0 release. We\nrecommend using the class  Zend\\HttpHandlerRunner\\RequestHandlerRunner  via\nthe package  zendframework/zend-httphandlerrunner \ninstead.   Zend\\Diactoros\\Server  represents a server capable of executing a callback. It has four methods:  class Server\n{\n    public function __construct(\n        callable $callback,\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    );\n    public static function createServer(\n        callable $callback,\n        array $server,  // usually $_SERVER\n        array $query,   // usually $_GET\n        array $body,    // usually $_POST\n        array $cookies, // usually $_COOKIE\n        array $files    // usually $_FILES\n    );\n    public static function createServerFromRequest(\n        callable $callback,\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response = null\n    );\n    public function setEmitter(Response\\EmitterInterface $emitter);\n    public function listen(callable $finalHandler = null);\n}  You can create an instance of the  Server  using any of the constructor,  createServer() , or createServerFromRequest()  methods. If you wish to use the default request and response\nimplementations,  createServer($middleware, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES)  is the\nrecommended option, as this method will also marshal the  ServerRequest  object based on the PHP\nrequest environment.  If you wish to use your own implementations, pass them to the constructor or createServerFromRequest()  method (the latter will create a default  Response  instance if you omit\nit).  listen()  executes the callback. If a  $finalHandler  is provided, it will be passed as the third\nargument to the  $callback  registered with the server.",
            "title": "Deprecated"
        },
        {
            "location": "/overview/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-diactoros/v2/overview/';\n  });",
            "title": "_overview"
        },
        {
            "location": "/install/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-diactoros/v2/install/';\n  });",
            "title": "_installation"
        },
        {
            "location": "/usage/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-diactoros/v2/usage/';\n  });",
            "title": "_usage"
        },
        {
            "location": "/custom-responses/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-diactoros/v2/custom-responses/';\n  });",
            "title": "_reference-custom-responses"
        },
        {
            "location": "/emitting-responses/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-diactoros/v1/emitting-responses/';\n  });",
            "title": "_reference-emitting-responses"
        },
        {
            "location": "/serialization/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-diactoros/v2/serialization/';\n  });",
            "title": "_reference-serialization"
        },
        {
            "location": "/api/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-diactoros/v2/api/';\n  });",
            "title": "_reference-api"
        }
    ]
}