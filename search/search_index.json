{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-diactoros Master: Develop: Diactoros (pronunciation: /d\u026a\u028ckt\u0252r\u0252s/ ): an epithet for Hermes, meaning literally, \"the messenger.\" This package supercedes and replaces phly/http . zend-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces and PSR-17 HTTP message factory interfaces . File issues at https://github.com/zendframework/zend-diactoros/issues Issue patches to https://github.com/zendframework/zend-diactoros/pulls Documentation Documentation is available at: https://docs.zendframework.com/zend-diactoros/ Source files for documentation are in the docs/ tree .","title":"Home"},{"location":"#zend-diactoros","text":"Master: Develop: Diactoros (pronunciation: /d\u026a\u028ckt\u0252r\u0252s/ ): an epithet for Hermes, meaning literally, \"the messenger.\" This package supercedes and replaces phly/http . zend-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces and PSR-17 HTTP message factory interfaces . File issues at https://github.com/zendframework/zend-diactoros/issues Issue patches to https://github.com/zendframework/zend-diactoros/pulls","title":"zend-diactoros"},{"location":"#documentation","text":"Documentation is available at: https://docs.zendframework.com/zend-diactoros/ Source files for documentation are in the docs/ tree .","title":"Documentation"},{"location":"api/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-diactoros/v2/api/'; });","title":"_reference-api"},{"location":"custom-responses/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-diactoros/v2/custom-responses/'; });","title":"_reference-custom-responses"},{"location":"emitting-responses/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-diactoros/v1/emitting-responses/'; });","title":"_reference-emitting-responses"},{"location":"install/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-diactoros/v2/install/'; });","title":"_installation"},{"location":"overview/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-diactoros/v2/overview/'; });","title":"_overview"},{"location":"serialization/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-diactoros/v2/serialization/'; });","title":"_reference-serialization"},{"location":"usage/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-diactoros/v2/usage/'; });","title":"_usage"},{"location":"v1/api/","text":"API Request Message Zend\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested. ServerRequest Message For server-side applications, Zend\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values. Response Message Zend\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested. HtmlResponse and JsonResponse Available since version 1.1.0 The most common use case in server-side applications for generating responses is to provide a string to use for the response, typically HTML or data to serialize as JSON. Zend\\Diactoros\\Response\\HtmlResponse and Zend\\Diactoros\\Response\\JsonResponse exist to facilitate these use cases: $htmlResponse = new HtmlResponse($html); $jsonResponse = new JsonResponse($data); In the first example, you will receive a response with a stream containing the HTML; additionally, the Content-Type header will be set to text/html . In the second case, the stream will contain a stream containing the JSON-serialized $data , and have a Content-Type header set to application/json . Both objects allow passing the HTTP status, as well as any headers you want to specify, including the Content-Type header: $htmlResponse = new HtmlResponse($html, 404, [ 'Content-Type' => [ 'application/xhtml+xml' ], ]); $jsonResponse = new JsonResponse($data, 422, [ 'Content-Type' => [ 'application/problem+json' ], ]); ServerRequestFactory This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Zend\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = RequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); ServerRequestFactory Helper Functions Available since version 1.8.0 In order to create the various artifacts required by a ServerRequest instance, Diactoros also provides a number of functions under the Zend\\Diactoros namespace for introspecting the SAPI $_SERVER parameters, headers, $_FILES , and even the Cookie header. These include: Zend\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array (its main purpose is to aggregate the Authorization header in the SAPI params when under Apache) Zend\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string Zend\\Diactoros\\marshalMethodFromSapi(array $server) : string Zend\\Diactoros\\marshalUriFromSapi(array $server, array $headers) : Uri Zend\\Diactoros\\marshalHeadersFromSapi(array $server) : array Zend\\Diactoros\\parseCookieHeader(string $header) : array Zend\\Diactoros\\createUploadedFile(array $spec) : UploadedFile (creates the instance from a normal $_FILES entry) Zend\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[] (traverses a potentially nested array of uploaded file instances and/or $_FILES entries, including those aggregated under mod_php, php-fpm, and php-cgi in order to create a flat array of UploadedFileInterface instances to use in a request) URI Zend\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested. Stream Zend\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be either: a stream identifier; e.g., php://input , a filename, etc. a PHP stream resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly. UploadedFile Zend\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface . Server Deprecated The class Zend\\Diactoros\\Server is deprecated as of the 1.8.0 release. We recommend using the class Zend\\HttpHandlerRunner\\RequestHandlerRunner via the package zendframework/zend-httphandlerrunner instead. Zend\\Diactoros\\Server represents a server capable of executing a callback. It has four methods: class Server { public function __construct( callable $callback, Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response ); public static function createServer( callable $callback, array $server, // usually $_SERVER array $query, // usually $_GET array $body, // usually $_POST array $cookies, // usually $_COOKIE array $files // usually $_FILES ); public static function createServerFromRequest( callable $callback, Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response = null ); public function setEmitter(Response\\EmitterInterface $emitter); public function listen(callable $finalHandler = null); } You can create an instance of the Server using any of the constructor, createServer() , or createServerFromRequest() methods. If you wish to use the default request and response implementations, createServer($middleware, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES) is the recommended option, as this method will also marshal the ServerRequest object based on the PHP request environment. If you wish to use your own implementations, pass them to the constructor or createServerFromRequest() method (the latter will create a default Response instance if you omit it). listen() executes the callback. If a $finalHandler is provided, it will be passed as the third argument to the $callback registered with the server.","title":"API"},{"location":"v1/api/#api","text":"","title":"API"},{"location":"v1/api/#request-message","text":"Zend\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested.","title":"Request Message"},{"location":"v1/api/#serverrequest-message","text":"For server-side applications, Zend\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values.","title":"ServerRequest Message"},{"location":"v1/api/#response-message","text":"Zend\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested.","title":"Response Message"},{"location":"v1/api/#serverrequestfactory","text":"This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Zend\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = RequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES );","title":"ServerRequestFactory"},{"location":"v1/api/#uri","text":"Zend\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested.","title":"URI"},{"location":"v1/api/#stream","text":"Zend\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be either: a stream identifier; e.g., php://input , a filename, etc. a PHP stream resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly.","title":"Stream"},{"location":"v1/api/#uploadedfile","text":"Zend\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"UploadedFile"},{"location":"v1/api/#server","text":"","title":"Server"},{"location":"v1/custom-responses/","text":"Custom Responses When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks. Text Responses Zend\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new TextResponse($text, 200, ['Content-Type' => ['text/csv']]); HTML Responses Zend\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' => ['application/xhtml+xml']]); Headers must be in the same format as you would provide to the Response constructor . XML Responses Available since version 1.7.0 Zend\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new XmlResponse($xml, 200, [ 'Content-Type' => ['application/hal+xml']]); Headers must be in the same format as you would provide to the Response constructor . JSON Responses Zend\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments \u2014 a status code, and an array of headers \u2014 to allow you to further seed the initial state of the response: $response = new JsonResponse($data, 200, [ 'Content-Type' => ['application/hal+json']]); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT ); Empty Responses Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Zend\\Diactoros\\Response\\EmptyResponse is a Zend\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' => [ $url ], ]); // Alternately, set the header after instantiation: $response = ( new EmptyResponse(201) )->withHeader('Location', $url); Redirects Zend\\Diactoros\\Response\\RedirectResponse is a Zend\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request->getUri(); $response = new RedirectResponse($uri->withPath('/login')); Creating custom Responses PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Response('php://temp', $status, $headers); $response->getBody()->write($text); if (! $response->hasHeader('Content-Type')) { $response = $response->withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Custom Responses"},{"location":"v1/custom-responses/#custom-responses","text":"When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks.","title":"Custom Responses"},{"location":"v1/custom-responses/#text-responses","text":"Zend\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new TextResponse($text, 200, ['Content-Type' => ['text/csv']]);","title":"Text Responses"},{"location":"v1/custom-responses/#html-responses","text":"Zend\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' => ['application/xhtml+xml']]); Headers must be in the same format as you would provide to the Response constructor .","title":"HTML Responses"},{"location":"v1/custom-responses/#xml-responses","text":"Available since version 1.7.0 Zend\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new XmlResponse($xml, 200, [ 'Content-Type' => ['application/hal+xml']]); Headers must be in the same format as you would provide to the Response constructor .","title":"XML Responses"},{"location":"v1/custom-responses/#json-responses","text":"Zend\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments \u2014 a status code, and an array of headers \u2014 to allow you to further seed the initial state of the response: $response = new JsonResponse($data, 200, [ 'Content-Type' => ['application/hal+json']]); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT );","title":"JSON Responses"},{"location":"v1/custom-responses/#empty-responses","text":"Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Zend\\Diactoros\\Response\\EmptyResponse is a Zend\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' => [ $url ], ]); // Alternately, set the header after instantiation: $response = ( new EmptyResponse(201) )->withHeader('Location', $url);","title":"Empty Responses"},{"location":"v1/custom-responses/#redirects","text":"Zend\\Diactoros\\Response\\RedirectResponse is a Zend\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request->getUri(); $response = new RedirectResponse($uri->withPath('/login'));","title":"Redirects"},{"location":"v1/custom-responses/#creating-custom-responses","text":"PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Response('php://temp', $status, $headers); $response->getBody()->write($text); if (! $response->hasHeader('Content-Type')) { $response = $response->withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Creating custom Responses"},{"location":"v1/emitting-responses/","text":"Emitting Responses Deprecated Emitters are deprecated from Diactoros starting with version 1.8.0. The functionality is now available for any PSR-7 implementation via the package zendframework/zend-httphandlerrunner . We suggest using that functionality instead. If you are using a non-SAPI PHP implementation and wish to use the Server class, or if you do not want to use the Server implementation but want to emit a response, this package provides an interface, Zend\\Diactoros\\Response\\EmitterInterface , defining a method emit() for emitting the response. Diactoros provides two implementations currently, both for working with traditional Server API (SAPI) implementations: Zend\\Diactoros\\Response\\SapiEmitter and Zend\\Diactoros\\Response\\SapiStreamEmitter . Each uses the native header() PHP function to emit headers, and echo() to emit the response body. If you are using a non-SAPI implementation, you will need to create your own EmitterInterface implementation. For example, the SapiEmitter implementation of the EmitterInterface can be used thus: $response = new Zend\\Diactoros\\Response(); $response->getBody()->write(\"some content\\n\"); $emitter = new Zend\\Diactoros\\Response\\SapiEmitter(); $emitter->emit($response); Emitting Ranges of streamed Files The SapiStreamEmitter is useful when you want to emit a Content-Range . As an example, to stream a range of bytes from a file to a client, the client can pass the following header: Range: bytes=1024-2047 Your application would then populate the response with a Content-Range header: $range = $request->getHeaderLine('range'); $range = str_replace('=', ' ', $range); $body = new Stream($pathToFile); $size = $body->getSize(); $range .= '/' . $size; $response = new Response($body); $response = $response->withHeader('Content-Range', $range); (Note: you will likely want to ensure the range specified falls within the content size of the streamed body!) The SapiStreamEmitter detects the Content-Range header and emits only the bytes specified. $emitter = new SapiStreamEmitter(); $emitter->emit($response); The SapiStreamEmitter may be used in place of the SapiEmitter , even when not sending files. However, unlike the SapiEmitter , it will emit a chunk of content at a time instead of the full content at once, which could lead to performance overhead. The default chunk size is 8192 bytes.","title":"Emitting Responses"},{"location":"v1/emitting-responses/#emitting-responses","text":"","title":"Emitting Responses"},{"location":"v1/emitting-responses/#emitting-ranges-of-streamed-files","text":"The SapiStreamEmitter is useful when you want to emit a Content-Range . As an example, to stream a range of bytes from a file to a client, the client can pass the following header: Range: bytes=1024-2047 Your application would then populate the response with a Content-Range header: $range = $request->getHeaderLine('range'); $range = str_replace('=', ' ', $range); $body = new Stream($pathToFile); $size = $body->getSize(); $range .= '/' . $size; $response = new Response($body); $response = $response->withHeader('Content-Range', $range); (Note: you will likely want to ensure the range specified falls within the content size of the streamed body!) The SapiStreamEmitter detects the Content-Range header and emits only the bytes specified. $emitter = new SapiStreamEmitter(); $emitter->emit($response); The SapiStreamEmitter may be used in place of the SapiEmitter , even when not sending files. However, unlike the SapiEmitter , it will emit a chunk of content at a time instead of the full content at once, which could lead to performance overhead. The default chunk size is 8192 bytes.","title":"Emitting Ranges of streamed Files"},{"location":"v1/install/","text":"Installation Install this library using composer: $ composer require \"zendframework/zend-diactoros:^1.8.6\" zend-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. zend-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v1/install/#installation","text":"Install this library using composer: $ composer require \"zendframework/zend-diactoros:^1.8.6\" zend-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. zend-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v1/overview/","text":"Overview zend-diactoros is a PHP package containing implementations of the accepted PSR-7 HTTP message interfaces , as well as a \"server\" implementation similar to node's http.Server . This package exists: to provide an implementation of PSR-7 HTTP message interfaces with relation to server-side applications. to provide a common methodology for marshaling a request from the server environment.","title":"Overview"},{"location":"v1/overview/#overview","text":"zend-diactoros is a PHP package containing implementations of the accepted PSR-7 HTTP message interfaces , as well as a \"server\" implementation similar to node's http.Server . This package exists: to provide an implementation of PSR-7 HTTP message interfaces with relation to server-side applications. to provide a common methodology for marshaling a request from the server environment.","title":"Overview"},{"location":"v1/serialization/","text":"Serialization String At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Zend\\Diactoros\\Request\\Serializer and Zend\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance. Array This package also provides features for array serialization using Zend\\Diactoros\\Request\\ArraySerializer and Zend\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message. Example Usage Array serialization can be usesful for log messages: class LoggerMiddleware { /** * @var \\Psr\\Log\\LoggerInterface */ protected $logger; public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next) { $response = $next($request, $response); $this->logger->debug('Request/Response', [ 'request' => \\Zend\\Diactoros\\Request\\ArraySerializer::toArray($request), 'response' => \\Zend\\Diactoros\\Response\\ArraySerializer::toArray($response), ]); return $response; } }","title":"Serialization"},{"location":"v1/serialization/#serialization","text":"","title":"Serialization"},{"location":"v1/serialization/#string","text":"At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Zend\\Diactoros\\Request\\Serializer and Zend\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance.","title":"String"},{"location":"v1/serialization/#array","text":"This package also provides features for array serialization using Zend\\Diactoros\\Request\\ArraySerializer and Zend\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message.","title":"Array"},{"location":"v1/usage/","text":"Usage Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance. HTTP Clients A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes \u2014 e.g., by calling setter methods \u2014 you must capture the return value, as it is a new instance. // Create a request $request = (new Zend\\Diactoros\\Request()) ->withUri(new Zend\\Diactoros\\Uri('http://example.com')) ->withMethod('PATCH') ->withAddedHeader('Authorization', 'Bearer ' . $token) ->withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Zend\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' => 'Bearer ' . $token, 'Content-Type' => 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request->withRequestTarget((string) $uri); // absolute-form $request = $request->withRequestTarget($uri->getAuthority()); // authority-form $request = $request->withRequestTarget('*'); // asterisk-form // Once you have the instance: $request->getBody()->write(json_encode($data)); $response = $client->send($request); printf(\"Response status: %d (%s)\\n\", $response->getStatusCode(), $response->getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response->getHeaders() as $header => $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response->getBody()); (Note: zend-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.) Server-Side Applications Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response. Marshaling an incoming Request PHP contains a plethora of information about the incoming request, and keeps that information in a variety of locations. Zend\\Diactoros\\ServerRequestFactory::fromGlobals() can simplify marshaling that information into a request instance. You can call the factory method with or without the following arguments, in the following order: $server , typically $_SERVER $query , typically $_GET $body , typically $_POST $cookies , typically $_COOKIE $files , typically $_FILES The method will then return a Zend\\Diactoros\\ServerRequest instance. If any argument is omitted, the associated superglobal will be used. $request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); When no cookie array is supplied, fromGlobals will first try to parse the supplied cookie header before falling back to the $_COOKIE superglobal. This is done because PHP has some legacy handling for request parameters which were then registered as global variables. Due to this, cookies with a period in the name were renamed with underlines. By getting the cookies directly from the cookie header, you have access to the original cookies in the way you set them in your application and they are send by the user agent. Manipulating the Response Use the response object to add headers and provide content for the response. Writing to the body does not create a state change in the response, so it can be done without capturing the return value. Manipulating headers does, however. $response = new Zend\\Diactoros\\Response(); // Write to the response body: $response->getBody()->write(\"some content\\n\"); // Multiple calls to write() append: $response->getBody()->write(\"more content\\n\"); // now \"some content\\nmore content\\n\" // Add headers // Note: headers do not need to be added before data is written to the body! $response = $response ->withHeader('Content-Type', 'text/plain') ->withAddedHeader('X-Show-Something', 'something'); \"Serving\" an Application Deprecated The class Zend\\Diactoros\\Server is deprecated as of the 1.8.0 release. We recommend using the class Zend\\HttpHandlerRunner\\RequestHandlerRunner via the package zendframework/zend-httphandlerrunner instead. Zend\\Diactoros\\Server mimics a portion of the API of node's http.Server class. It invokes a callback, passing it an ServerRequest , an Response , and optionally a callback to use for incomplete/unhandled requests. You can create a server in one of three ways: // Direct instantiation, with a callback handler, request, and response $server = new Zend\\Diactoros\\Server( function ($request, $response, $done) { $response->getBody()->write(\"Hello world!\"); }, $request, $response ); // Using the createServer factory, providing it with the various superglobals: $server = Zend\\Diactoros\\Server::createServer( function ($request, $response, $done) { $response->getBody()->write(\"Hello world!\"); }, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); // Using the createServerFromRequest factory, and providing it a request: $server = Zend\\Diactoros\\Server::createServerFromRequest( function ($request, $response, $done) { $response->getBody()->write(\"Hello world!\"); }, $request ); Server callbacks can expect up to three arguments, in the following order: $request - the request object $response - the response object $done - an optional callback to call when complete Once you have your server instance, you must instruct it to listen: $server->listen(); At this time, you can optionally provide a callback to listen() ; this will be passed to the handler as the third argument ( $done ): $server->listen(function ($request, $response, $error = null) { if (! $error) { return; } // do something with the error... }); Typically, the listen callback will be an error handler, and can expect to receive the request, response, and error as its arguments (though the error may be null).","title":"Usage"},{"location":"v1/usage/#usage","text":"Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance.","title":"Usage"},{"location":"v1/usage/#http-clients","text":"A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes \u2014 e.g., by calling setter methods \u2014 you must capture the return value, as it is a new instance. // Create a request $request = (new Zend\\Diactoros\\Request()) ->withUri(new Zend\\Diactoros\\Uri('http://example.com')) ->withMethod('PATCH') ->withAddedHeader('Authorization', 'Bearer ' . $token) ->withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Zend\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' => 'Bearer ' . $token, 'Content-Type' => 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request->withRequestTarget((string) $uri); // absolute-form $request = $request->withRequestTarget($uri->getAuthority()); // authority-form $request = $request->withRequestTarget('*'); // asterisk-form // Once you have the instance: $request->getBody()->write(json_encode($data)); $response = $client->send($request); printf(\"Response status: %d (%s)\\n\", $response->getStatusCode(), $response->getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response->getHeaders() as $header => $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response->getBody()); (Note: zend-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.)","title":"HTTP Clients"},{"location":"v1/usage/#server-side-applications","text":"Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response.","title":"Server-Side Applications"},{"location":"v2/api/","text":"API Request Message Zend\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested. ServerRequest Message For server-side applications, Zend\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values. Response Message Zend\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested. HtmlResponse and JsonResponse The most common use case in server-side applications for generating responses is to provide a string to use for the response, typically HTML or data to serialize as JSON. Zend\\Diactoros\\Response\\HtmlResponse and Zend\\Diactoros\\Response\\JsonResponse exist to facilitate these use cases: $htmlResponse = new HtmlResponse($html); $jsonResponse = new JsonResponse($data); In the first example, you will receive a response with a stream containing the HTML; additionally, the Content-Type header will be set to text/html . In the second case, the stream will contain a stream containing the JSON-serialized $data , and have a Content-Type header set to application/json . Both objects allow passing the HTTP status, as well as any headers you want to specify, including the Content-Type header: $htmlResponse = new HtmlResponse($html, 404, [ 'Content-Type' => [ 'application/xhtml+xml' ], ]); $jsonResponse = new JsonResponse($data, 422, [ 'Content-Type' => [ 'application/problem+json' ], ]); ServerRequestFactory This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Zend\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = RequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); ServerRequestFactory Helper Functions In order to create the various artifacts required by a ServerRequest instance, Diactoros also provides a number of functions under the Zend\\Diactoros namespace for introspecting the SAPI $_SERVER parameters, headers, $_FILES , and even the Cookie header. These include: Zend\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array (its main purpose is to aggregate the Authorization header in the SAPI params when under Apache) Zend\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string Zend\\Diactoros\\marshalMethodFromSapi(array $server) : string Zend\\Diactoros\\marshalUriFromSapi(array $server, array $headers) : Uri Zend\\Diactoros\\marshalHeadersFromSapi(array $server) : array Zend\\Diactoros\\parseCookieHeader(string $header) : array Zend\\Diactoros\\createUploadedFile(array $spec) : UploadedFile (creates the instance from a normal $_FILES entry) Zend\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[] (traverses a potentially nested array of uploaded file instances and/or $_FILES entries, including those aggregated under mod_php, php-fpm, and php-cgi in order to create a flat array of UploadedFileInterface instances to use in a request) URI Zend\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested. Stream Zend\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be either: a stream identifier; e.g., php://input , a filename, etc. a PHP stream resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly. UploadedFile Zend\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. Additionally, it extends PHP's build in SplFileInfo object in order to provide a compatible interface wherever such an object is needed. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"API"},{"location":"v2/api/#api","text":"","title":"API"},{"location":"v2/api/#request-message","text":"Zend\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested.","title":"Request Message"},{"location":"v2/api/#serverrequest-message","text":"For server-side applications, Zend\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values.","title":"ServerRequest Message"},{"location":"v2/api/#response-message","text":"Zend\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested.","title":"Response Message"},{"location":"v2/api/#serverrequestfactory","text":"This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Zend\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = RequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES );","title":"ServerRequestFactory"},{"location":"v2/api/#uri","text":"Zend\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state \u2014 those prefixed with with and without \u2014 all return a new instance with the changes requested.","title":"URI"},{"location":"v2/api/#stream","text":"Zend\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be either: a stream identifier; e.g., php://input , a filename, etc. a PHP stream resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly.","title":"Stream"},{"location":"v2/api/#uploadedfile","text":"Zend\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. Additionally, it extends PHP's build in SplFileInfo object in order to provide a compatible interface wherever such an object is needed. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"UploadedFile"},{"location":"v2/custom-responses/","text":"Custom Responses When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: namespace Zend\\Diactoros; use Psr\\Http\\Message\\ResponseInterface; class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks. Text Responses Zend\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new Zend\\Diactoros\\Response\\TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new Zend\\Diactoros\\Response\\TextResponse( $text, 200, ['Content-Type' => ['text/csv']] ); HTML Responses Zend\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new Zend\\Diactoros\\Response\\HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Zend\\Diactoros\\Response\\HtmlResponse( $htmlContent, 200, ['Content-Type' => ['application/xhtml+xml']] ); Headers must be in the same format as you would provide to the Response constructor . XML Responses Zend\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new Zend\\Diactoros\\Response\\XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Zend\\Diactoros\\Response\\XmlResponse( $xml, 200, ['Content-Type' => ['application/hal+xml']] ); Headers must be in the same format as you would provide to the Response constructor . JSON Responses Zend\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new Zend\\Diactoros\\Response\\JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments \u2014 a status code, and an array of headers \u2014 to allow you to further seed the initial state of the response: $response = new Zend\\Diactoros\\Response\\JsonResponse( $data, 200, ['Content-Type' => ['application/hal+json']] ); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new Zend\\Diactoros\\Response\\JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT ); Empty Responses Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Zend\\Diactoros\\Response\\EmptyResponse is a Zend\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: namespace Zend\\Diactoros\\Response; use Zend\\Diactoros\\Response; class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: use Zend\\Diactoros\\Response\\EmptyResponse; // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' => [ $url ], ]); // Alternately, set the header after instantiation: $response = (new EmptyResponse(201))->withHeader('Location', $url); Redirects Zend\\Diactoros\\Response\\RedirectResponse is a Zend\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: namespace Zend\\Diactoros\\Response; use Zend\\Diactoros\\Response; class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: use Zend\\Diactoros\\Response\\RedirectResponse; // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request->getUri(); $response = new RedirectResponse($uri->withPath('/login')); Creating custom Responses PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: use Zend\\Diactoros\\Response; class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Zend\\Diactoros\\Response('php://temp', $status, $headers); $response->getBody()->write($text); if (! $response->hasHeader('Content-Type')) { $response = $response->withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Custom Responses"},{"location":"v2/custom-responses/#custom-responses","text":"When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: namespace Zend\\Diactoros; use Psr\\Http\\Message\\ResponseInterface; class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks.","title":"Custom Responses"},{"location":"v2/custom-responses/#text-responses","text":"Zend\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new Zend\\Diactoros\\Response\\TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new Zend\\Diactoros\\Response\\TextResponse( $text, 200, ['Content-Type' => ['text/csv']] );","title":"Text Responses"},{"location":"v2/custom-responses/#html-responses","text":"Zend\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new Zend\\Diactoros\\Response\\HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Zend\\Diactoros\\Response\\HtmlResponse( $htmlContent, 200, ['Content-Type' => ['application/xhtml+xml']] ); Headers must be in the same format as you would provide to the Response constructor .","title":"HTML Responses"},{"location":"v2/custom-responses/#xml-responses","text":"Zend\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new Zend\\Diactoros\\Response\\XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Zend\\Diactoros\\Response\\XmlResponse( $xml, 200, ['Content-Type' => ['application/hal+xml']] ); Headers must be in the same format as you would provide to the Response constructor .","title":"XML Responses"},{"location":"v2/custom-responses/#json-responses","text":"Zend\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new Zend\\Diactoros\\Response\\JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments \u2014 a status code, and an array of headers \u2014 to allow you to further seed the initial state of the response: $response = new Zend\\Diactoros\\Response\\JsonResponse( $data, 200, ['Content-Type' => ['application/hal+json']] ); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new Zend\\Diactoros\\Response\\JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT );","title":"JSON Responses"},{"location":"v2/custom-responses/#empty-responses","text":"Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Zend\\Diactoros\\Response\\EmptyResponse is a Zend\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: namespace Zend\\Diactoros\\Response; use Zend\\Diactoros\\Response; class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: use Zend\\Diactoros\\Response\\EmptyResponse; // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' => [ $url ], ]); // Alternately, set the header after instantiation: $response = (new EmptyResponse(201))->withHeader('Location', $url);","title":"Empty Responses"},{"location":"v2/custom-responses/#redirects","text":"Zend\\Diactoros\\Response\\RedirectResponse is a Zend\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: namespace Zend\\Diactoros\\Response; use Zend\\Diactoros\\Response; class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: use Zend\\Diactoros\\Response\\RedirectResponse; // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request->getUri(); $response = new RedirectResponse($uri->withPath('/login'));","title":"Redirects"},{"location":"v2/custom-responses/#creating-custom-responses","text":"PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: use Zend\\Diactoros\\Response; class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Zend\\Diactoros\\Response('php://temp', $status, $headers); $response->getBody()->write($text); if (! $response->hasHeader('Content-Type')) { $response = $response->withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Creating custom Responses"},{"location":"v2/factories/","text":"Factories PSR-17 defines factory interfaces for creating PSR-7 instances. As of version 2.0.0, Diactoros supplies implementations of each as follows: Zend\\Diactoros\\RequestFactory Zend\\Diactoros\\ResponseFactory Zend\\Diactoros\\ServerRequestFactory Zend\\Diactoros\\StreamFactory Zend\\Diactoros\\UploadedFileFactory Zend\\Diactoros\\UriFactory The ServerRequestFactory continues to define the static method fromGlobals() , but also serves as a PSR-17 implementation. These classes may be used as described in the specification document for the purpose of creating Diactoros instances that fulfill PSR-7 typehints.","title":"Factories"},{"location":"v2/factories/#factories","text":"PSR-17 defines factory interfaces for creating PSR-7 instances. As of version 2.0.0, Diactoros supplies implementations of each as follows: Zend\\Diactoros\\RequestFactory Zend\\Diactoros\\ResponseFactory Zend\\Diactoros\\ServerRequestFactory Zend\\Diactoros\\StreamFactory Zend\\Diactoros\\UploadedFileFactory Zend\\Diactoros\\UriFactory The ServerRequestFactory continues to define the static method fromGlobals() , but also serves as a PSR-17 implementation. These classes may be used as described in the specification document for the purpose of creating Diactoros instances that fulfill PSR-7 typehints.","title":"Factories"},{"location":"v2/install/","text":"Installation Install this library using composer: $ composer require zendframework/zend-diactoros zend-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. zend-diactoros provides implementations of each of these. psr/http-factory , which defines interfaces for HTTP message factories. zend-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v2/install/#installation","text":"Install this library using composer: $ composer require zendframework/zend-diactoros zend-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. zend-diactoros provides implementations of each of these. psr/http-factory , which defines interfaces for HTTP message factories. zend-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v2/migration/","text":"Migration to Version 2 If you are only using the PSR-7 implementations (e.g., Request , Response , ServerRequest , etc.), migrating to v2 can be done by updating your zendframework/zend-diactoros constraint in your composer.json . You have two options for doing so: Adopt the v2 release specifically: bash $ composer require \"zendframework/zend-diactoros:^2.0\" Update your constraint to allow either version: Edit the constraint in your composer.json to read: json \"zendframework/zend-diactoros\": \"^1.8.6 || ^2.0\" Update your dependencies: bash $ composer update The first approach may fail if libraries you depend on specifically require a version 1 release. The second approach may leave you on a version 1 release in situations where other libraries you depend on require version 1. In all cases, if you are only using the PSR-7 implementations and/or the ServerRequestFactory::fromGlobals() functionality, upgrading to version 2 will pose no backwards compatibility issues. Changed Zend\\Diactoros\\RequestTrait now raises an InvalidArgumentException in withMethod() for invalid HTTP method values. Zend\\Diactoros\\Serializer\\Request::toString() no longer raises an UnexpectedValueException due to an unexpected HTTP method; this is due to the fact that the HTTP method value can no longer be set to an invalid value. Removed Several features were removed for version 2. These include removal of the Emitter functionality, the Server implementation, and a number of methods on the ServerRequestFactory . Emitters Zend\\Diactoros\\Response\\EmitterInterface and all emitter implementations were removed from zend-diactoros. They are now available in the zendframework/zend-httphandlerrunner package . In most cases, these can be replaced by changing the namespace of imported classes from Zend\\Diactoros\\Response to Zend\\HttpHandlerRunner\\Emitter . Server The Zend\\Diactoros\\Server class has been removed. We recommend using the RequestHandlerRunner class from zendframework/zend-httphandlerrunner to provide these capabilities instead. Usage is similar, but the RequestHandlerRunner provides better error handling, and integration with emitters. ServerRequestFactory Methods A number of public static methods have been removed from ServerRequestFactory . The following table details the methods removed, and replacements you may use if you still require the functionality. Method Removed Replacement functionality normalizeServer() Zend\\Diactoros\\normalizeServer() marshalHeaders() Zend\\Diactoros\\marshalHeadersFromSapi() marshalUriFromServer() Zend\\Diactoros\\marshalUriFromSapi() marshalRequestUri() Uri::getPath() from the Uri instance returned by marshalUriFromSapi() marshalHostAndPortFromHeaders() Uri::getHost() and Uri::getPort() from the Uri instances returned by marshalUriFromSapi() stripQueryString() explode(\"?\", $path, 2)[0] normalizeFiles() Zend\\Diactoros\\normalizeUploadedFiles()","title":"Migration to Version 2"},{"location":"v2/migration/#migration-to-version-2","text":"If you are only using the PSR-7 implementations (e.g., Request , Response , ServerRequest , etc.), migrating to v2 can be done by updating your zendframework/zend-diactoros constraint in your composer.json . You have two options for doing so: Adopt the v2 release specifically: bash $ composer require \"zendframework/zend-diactoros:^2.0\" Update your constraint to allow either version: Edit the constraint in your composer.json to read: json \"zendframework/zend-diactoros\": \"^1.8.6 || ^2.0\" Update your dependencies: bash $ composer update The first approach may fail if libraries you depend on specifically require a version 1 release. The second approach may leave you on a version 1 release in situations where other libraries you depend on require version 1. In all cases, if you are only using the PSR-7 implementations and/or the ServerRequestFactory::fromGlobals() functionality, upgrading to version 2 will pose no backwards compatibility issues.","title":"Migration to Version 2"},{"location":"v2/migration/#changed","text":"Zend\\Diactoros\\RequestTrait now raises an InvalidArgumentException in withMethod() for invalid HTTP method values. Zend\\Diactoros\\Serializer\\Request::toString() no longer raises an UnexpectedValueException due to an unexpected HTTP method; this is due to the fact that the HTTP method value can no longer be set to an invalid value.","title":"Changed"},{"location":"v2/migration/#removed","text":"Several features were removed for version 2. These include removal of the Emitter functionality, the Server implementation, and a number of methods on the ServerRequestFactory .","title":"Removed"},{"location":"v2/overview/","text":"Overview zend-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces , as well as the PSR-17 HTTP message factory interfaces .","title":"Overview"},{"location":"v2/overview/#overview","text":"zend-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces , as well as the PSR-17 HTTP message factory interfaces .","title":"Overview"},{"location":"v2/serialization/","text":"Serialization String At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Zend\\Diactoros\\Request\\Serializer and Zend\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance. Array This package also provides features for array serialization using Zend\\Diactoros\\Request\\ArraySerializer and Zend\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message. Example Usage Array serialization can be usesful for log messages: class LoggerMiddleware { /** * @var \\Psr\\Log\\LoggerInterface */ protected $logger; public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next) { $response = $next($request, $response); $this->logger->debug('Request/Response', [ 'request' => \\Zend\\Diactoros\\Request\\ArraySerializer::toArray($request), 'response' => \\Zend\\Diactoros\\Response\\ArraySerializer::toArray($response), ]); return $response; } }","title":"Serialization"},{"location":"v2/serialization/#serialization","text":"","title":"Serialization"},{"location":"v2/serialization/#string","text":"At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Zend\\Diactoros\\Request\\Serializer and Zend\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance.","title":"String"},{"location":"v2/serialization/#array","text":"This package also provides features for array serialization using Zend\\Diactoros\\Request\\ArraySerializer and Zend\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message.","title":"Array"},{"location":"v2/usage/","text":"Usage Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance. HTTP Clients A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes \u2014 e.g., by calling setter methods \u2014 you must capture the return value, as it is a new instance. // Create a request $request = (new Zend\\Diactoros\\Request()) ->withUri(new Zend\\Diactoros\\Uri('http://example.com')) ->withMethod('PATCH') ->withAddedHeader('Authorization', 'Bearer ' . $token) ->withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Zend\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' => 'Bearer ' . $token, 'Content-Type' => 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request->withRequestTarget((string) $uri); // absolute-form $request = $request->withRequestTarget($uri->getAuthority()); // authority-form $request = $request->withRequestTarget('*'); // asterisk-form // Once you have the instance: $request->getBody()->write(json_encode($data)); $response = $client->send($request); printf(\"Response status: %d (%s)\\n\", $response->getStatusCode(), $response->getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response->getHeaders() as $header => $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response->getBody()); (Note: zend-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.) Server-Side Applications Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response. Marshaling an incoming Request PHP contains a plethora of information about the incoming request, and keeps that information in a variety of locations. Zend\\Diactoros\\ServerRequestFactory::fromGlobals() can simplify marshaling that information into a request instance. You can call the factory method with or without the following arguments, in the following order: $server , typically $_SERVER $query , typically $_GET $body , typically $_POST $cookies , typically $_COOKIE $files , typically $_FILES The method will then return a Zend\\Diactoros\\ServerRequest instance. If any argument is omitted, the associated superglobal will be used. $request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); When no cookie array is supplied, fromGlobals will first try to parse the supplied cookie header before falling back to the $_COOKIE superglobal. This is done because PHP has some legacy handling for request parameters which were then registered as global variables. Due to this, cookies with a period in the name were renamed with underlines. By getting the cookies directly from the cookie header, you have access to the original cookies in the way you set them in your application and they are send by the user agent. Manipulating the Response Use the response object to add headers and provide content for the response. Writing to the body does not create a state change in the response, so it can be done without capturing the return value. Manipulating headers does, however. $response = new Zend\\Diactoros\\Response(); // Write to the response body: $response->getBody()->write(\"some content\\n\"); // Multiple calls to write() append: $response->getBody()->write(\"more content\\n\"); // now \"some content\\nmore content\\n\" // Add headers // Note: headers do not need to be added before data is written to the body! $response = $response ->withHeader('Content-Type', 'text/plain') ->withAddedHeader('X-Show-Something', 'something');","title":"Usage"},{"location":"v2/usage/#usage","text":"Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance.","title":"Usage"},{"location":"v2/usage/#http-clients","text":"A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes \u2014 e.g., by calling setter methods \u2014 you must capture the return value, as it is a new instance. // Create a request $request = (new Zend\\Diactoros\\Request()) ->withUri(new Zend\\Diactoros\\Uri('http://example.com')) ->withMethod('PATCH') ->withAddedHeader('Authorization', 'Bearer ' . $token) ->withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Zend\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' => 'Bearer ' . $token, 'Content-Type' => 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request->withRequestTarget((string) $uri); // absolute-form $request = $request->withRequestTarget($uri->getAuthority()); // authority-form $request = $request->withRequestTarget('*'); // asterisk-form // Once you have the instance: $request->getBody()->write(json_encode($data)); $response = $client->send($request); printf(\"Response status: %d (%s)\\n\", $response->getStatusCode(), $response->getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response->getHeaders() as $header => $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response->getBody()); (Note: zend-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.)","title":"HTTP Clients"},{"location":"v2/usage/#server-side-applications","text":"Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response.","title":"Server-Side Applications"}]}